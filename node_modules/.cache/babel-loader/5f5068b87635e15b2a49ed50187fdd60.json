{"ast":null,"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.Immutable = {});\n})(this, function (exports) {\n  'use strict'; // Used for setting prototype methods that IE8 chokes on.\n\n  var DELETE = 'delete'; // Constants describing the size of trie nodes.\n\n  var SHIFT = 5; // Resulted in best performance after ______?\n\n  var SIZE = 1 << SHIFT;\n  var MASK = SIZE - 1; // A consistent shared value representing \"not set\" which equals nothing other\n  // than itself, and nothing that could be provided externally.\n\n  var NOT_SET = {}; // Boolean references, Rough equivalent of `bool &`.\n\n  function MakeRef() {\n    return {\n      value: false\n    };\n  }\n\n  function SetRef(ref) {\n    if (ref) {\n      ref.value = true;\n    }\n  } // A function which returns a value representing an \"owner\" for transient writes\n  // to tries. The return value will only ever equal itself, and will not equal\n  // the return of any subsequent call of this function.\n\n\n  function OwnerID() {}\n\n  function ensureSize(iter) {\n    if (iter.size === undefined) {\n      iter.size = iter.__iterate(returnTrue);\n    }\n\n    return iter.size;\n  }\n\n  function wrapIndex(iter, index) {\n    // This implements \"is array index\" which the ECMAString spec defines as:\n    //\n    //     A String property name P is an array index if and only if\n    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n    //     to 2^32âˆ’1.\n    //\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n    if (typeof index !== 'number') {\n      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n\n      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n        return NaN;\n      }\n\n      index = uint32Index;\n    }\n\n    return index < 0 ? ensureSize(iter) + index : index;\n  }\n\n  function returnTrue() {\n    return true;\n  }\n\n  function wholeSlice(begin, end, size) {\n    return (begin === 0 && !isNeg(begin) || size !== undefined && begin <= -size) && (end === undefined || size !== undefined && end >= size);\n  }\n\n  function resolveBegin(begin, size) {\n    return resolveIndex(begin, size, 0);\n  }\n\n  function resolveEnd(end, size) {\n    return resolveIndex(end, size, size);\n  }\n\n  function resolveIndex(index, size, defaultIndex) {\n    // Sanitize indices using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    return index === undefined ? defaultIndex : isNeg(index) ? size === Infinity ? size : Math.max(0, size + index) | 0 : size === undefined || size === index ? index : Math.min(size, index) | 0;\n  }\n\n  function isNeg(value) {\n    // Account for -0 which is negative, but not less than 0.\n    return value < 0 || value === 0 && 1 / value === -Infinity;\n  } // Note: value is unchanged to not break immutable-devtools.\n\n\n  var IS_COLLECTION_SYMBOL = '@@__IMMUTABLE_ITERABLE__@@';\n\n  function isCollection(maybeCollection) {\n    return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);\n  }\n\n  var IS_KEYED_SYMBOL = '@@__IMMUTABLE_KEYED__@@';\n\n  function isKeyed(maybeKeyed) {\n    return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);\n  }\n\n  var IS_INDEXED_SYMBOL = '@@__IMMUTABLE_INDEXED__@@';\n\n  function isIndexed(maybeIndexed) {\n    return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);\n  }\n\n  function isAssociative(maybeAssociative) {\n    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n  }\n\n  var Collection = function Collection(value) {\n    return isCollection(value) ? value : Seq(value);\n  };\n\n  var KeyedCollection =\n  /*@__PURE__*/\n  function (Collection) {\n    function KeyedCollection(value) {\n      return isKeyed(value) ? value : KeyedSeq(value);\n    }\n\n    if (Collection) KeyedCollection.__proto__ = Collection;\n    KeyedCollection.prototype = Object.create(Collection && Collection.prototype);\n    KeyedCollection.prototype.constructor = KeyedCollection;\n    return KeyedCollection;\n  }(Collection);\n\n  var IndexedCollection =\n  /*@__PURE__*/\n  function (Collection) {\n    function IndexedCollection(value) {\n      return isIndexed(value) ? value : IndexedSeq(value);\n    }\n\n    if (Collection) IndexedCollection.__proto__ = Collection;\n    IndexedCollection.prototype = Object.create(Collection && Collection.prototype);\n    IndexedCollection.prototype.constructor = IndexedCollection;\n    return IndexedCollection;\n  }(Collection);\n\n  var SetCollection =\n  /*@__PURE__*/\n  function (Collection) {\n    function SetCollection(value) {\n      return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);\n    }\n\n    if (Collection) SetCollection.__proto__ = Collection;\n    SetCollection.prototype = Object.create(Collection && Collection.prototype);\n    SetCollection.prototype.constructor = SetCollection;\n    return SetCollection;\n  }(Collection);\n\n  Collection.Keyed = KeyedCollection;\n  Collection.Indexed = IndexedCollection;\n  Collection.Set = SetCollection;\n  var IS_SEQ_SYMBOL = '@@__IMMUTABLE_SEQ__@@';\n\n  function isSeq(maybeSeq) {\n    return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);\n  }\n\n  var IS_RECORD_SYMBOL = '@@__IMMUTABLE_RECORD__@@';\n\n  function isRecord(maybeRecord) {\n    return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);\n  }\n\n  function isImmutable(maybeImmutable) {\n    return isCollection(maybeImmutable) || isRecord(maybeImmutable);\n  }\n\n  var IS_ORDERED_SYMBOL = '@@__IMMUTABLE_ORDERED__@@';\n\n  function isOrdered(maybeOrdered) {\n    return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);\n  }\n\n  var ITERATE_KEYS = 0;\n  var ITERATE_VALUES = 1;\n  var ITERATE_ENTRIES = 2;\n  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\n  var Iterator = function Iterator(next) {\n    this.next = next;\n  };\n\n  Iterator.prototype.toString = function toString() {\n    return '[Iterator]';\n  };\n\n  Iterator.KEYS = ITERATE_KEYS;\n  Iterator.VALUES = ITERATE_VALUES;\n  Iterator.ENTRIES = ITERATE_ENTRIES;\n\n  Iterator.prototype.inspect = Iterator.prototype.toSource = function () {\n    return this.toString();\n  };\n\n  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n    return this;\n  };\n\n  function iteratorValue(type, k, v, iteratorResult) {\n    var value = type === 0 ? k : type === 1 ? v : [k, v];\n    iteratorResult ? iteratorResult.value = value : iteratorResult = {\n      value: value,\n      done: false\n    };\n    return iteratorResult;\n  }\n\n  function iteratorDone() {\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  function hasIterator(maybeIterable) {\n    return !!getIteratorFn(maybeIterable);\n  }\n\n  function isIterator(maybeIterator) {\n    return maybeIterator && typeof maybeIterator.next === 'function';\n  }\n\n  function getIterator(iterable) {\n    var iteratorFn = getIteratorFn(iterable);\n    return iteratorFn && iteratorFn.call(iterable);\n  }\n\n  function getIteratorFn(iterable) {\n    var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);\n\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  function isArrayLike(value) {\n    if (Array.isArray(value) || typeof value === 'string') {\n      return true;\n    }\n\n    return value && typeof value === 'object' && Number.isInteger(value.length) && value.length >= 0 && (value.length === 0 ? // Only {length: 0} is considered Array-like.\n    Object.keys(value).length === 1 : // An object is only Array-like if it has a property where the last value\n    // in the array-like may be found (which could be undefined).\n    value.hasOwnProperty(value.length - 1));\n  }\n\n  var Seq =\n  /*@__PURE__*/\n  function (Collection$$1) {\n    function Seq(value) {\n      return value === null || value === undefined ? emptySequence() : isImmutable(value) ? value.toSeq() : seqFromValue(value);\n    }\n\n    if (Collection$$1) Seq.__proto__ = Collection$$1;\n    Seq.prototype = Object.create(Collection$$1 && Collection$$1.prototype);\n    Seq.prototype.constructor = Seq;\n\n    Seq.prototype.toSeq = function toSeq() {\n      return this;\n    };\n\n    Seq.prototype.toString = function toString() {\n      return this.__toString('Seq {', '}');\n    };\n\n    Seq.prototype.cacheResult = function cacheResult() {\n      if (!this._cache && this.__iterateUncached) {\n        this._cache = this.entrySeq().toArray();\n        this.size = this._cache.length;\n      }\n\n      return this;\n    }; // abstract __iterateUncached(fn, reverse)\n\n\n    Seq.prototype.__iterate = function __iterate(fn, reverse) {\n      var cache = this._cache;\n\n      if (cache) {\n        var size = cache.length;\n        var i = 0;\n\n        while (i !== size) {\n          var entry = cache[reverse ? size - ++i : i++];\n\n          if (fn(entry[1], entry[0], this) === false) {\n            break;\n          }\n        }\n\n        return i;\n      }\n\n      return this.__iterateUncached(fn, reverse);\n    }; // abstract __iteratorUncached(type, reverse)\n\n\n    Seq.prototype.__iterator = function __iterator(type, reverse) {\n      var cache = this._cache;\n\n      if (cache) {\n        var size = cache.length;\n        var i = 0;\n        return new Iterator(function () {\n          if (i === size) {\n            return iteratorDone();\n          }\n\n          var entry = cache[reverse ? size - ++i : i++];\n          return iteratorValue(type, entry[0], entry[1]);\n        });\n      }\n\n      return this.__iteratorUncached(type, reverse);\n    };\n\n    return Seq;\n  }(Collection);\n\n  var KeyedSeq =\n  /*@__PURE__*/\n  function (Seq) {\n    function KeyedSeq(value) {\n      return value === null || value === undefined ? emptySequence().toKeyedSeq() : isCollection(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);\n    }\n\n    if (Seq) KeyedSeq.__proto__ = Seq;\n    KeyedSeq.prototype = Object.create(Seq && Seq.prototype);\n    KeyedSeq.prototype.constructor = KeyedSeq;\n\n    KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq() {\n      return this;\n    };\n\n    return KeyedSeq;\n  }(Seq);\n\n  var IndexedSeq =\n  /*@__PURE__*/\n  function (Seq) {\n    function IndexedSeq(value) {\n      return value === null || value === undefined ? emptySequence() : isCollection(value) ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq() : isRecord(value) ? value.toSeq().entrySeq() : indexedSeqFromValue(value);\n    }\n\n    if (Seq) IndexedSeq.__proto__ = Seq;\n    IndexedSeq.prototype = Object.create(Seq && Seq.prototype);\n    IndexedSeq.prototype.constructor = IndexedSeq;\n\n    IndexedSeq.of = function of()\n    /*...values*/\n    {\n      return IndexedSeq(arguments);\n    };\n\n    IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq() {\n      return this;\n    };\n\n    IndexedSeq.prototype.toString = function toString() {\n      return this.__toString('Seq [', ']');\n    };\n\n    return IndexedSeq;\n  }(Seq);\n\n  var SetSeq =\n  /*@__PURE__*/\n  function (Seq) {\n    function SetSeq(value) {\n      return (isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)).toSetSeq();\n    }\n\n    if (Seq) SetSeq.__proto__ = Seq;\n    SetSeq.prototype = Object.create(Seq && Seq.prototype);\n    SetSeq.prototype.constructor = SetSeq;\n\n    SetSeq.of = function of()\n    /*...values*/\n    {\n      return SetSeq(arguments);\n    };\n\n    SetSeq.prototype.toSetSeq = function toSetSeq() {\n      return this;\n    };\n\n    return SetSeq;\n  }(Seq);\n\n  Seq.isSeq = isSeq;\n  Seq.Keyed = KeyedSeq;\n  Seq.Set = SetSeq;\n  Seq.Indexed = IndexedSeq;\n  Seq.prototype[IS_SEQ_SYMBOL] = true; // #pragma Root Sequences\n\n  var ArraySeq =\n  /*@__PURE__*/\n  function (IndexedSeq) {\n    function ArraySeq(array) {\n      this._array = array;\n      this.size = array.length;\n    }\n\n    if (IndexedSeq) ArraySeq.__proto__ = IndexedSeq;\n    ArraySeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);\n    ArraySeq.prototype.constructor = ArraySeq;\n\n    ArraySeq.prototype.get = function get(index, notSetValue) {\n      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n    };\n\n    ArraySeq.prototype.__iterate = function __iterate(fn, reverse) {\n      var array = this._array;\n      var size = array.length;\n      var i = 0;\n\n      while (i !== size) {\n        var ii = reverse ? size - ++i : i++;\n\n        if (fn(array[ii], ii, this) === false) {\n          break;\n        }\n      }\n\n      return i;\n    };\n\n    ArraySeq.prototype.__iterator = function __iterator(type, reverse) {\n      var array = this._array;\n      var size = array.length;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n\n        var ii = reverse ? size - ++i : i++;\n        return iteratorValue(type, ii, array[ii]);\n      });\n    };\n\n    return ArraySeq;\n  }(IndexedSeq);\n\n  var ObjectSeq =\n  /*@__PURE__*/\n  function (KeyedSeq) {\n    function ObjectSeq(object) {\n      var keys = Object.keys(object);\n      this._object = object;\n      this._keys = keys;\n      this.size = keys.length;\n    }\n\n    if (KeyedSeq) ObjectSeq.__proto__ = KeyedSeq;\n    ObjectSeq.prototype = Object.create(KeyedSeq && KeyedSeq.prototype);\n    ObjectSeq.prototype.constructor = ObjectSeq;\n\n    ObjectSeq.prototype.get = function get(key, notSetValue) {\n      if (notSetValue !== undefined && !this.has(key)) {\n        return notSetValue;\n      }\n\n      return this._object[key];\n    };\n\n    ObjectSeq.prototype.has = function has(key) {\n      return hasOwnProperty.call(this._object, key);\n    };\n\n    ObjectSeq.prototype.__iterate = function __iterate(fn, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var size = keys.length;\n      var i = 0;\n\n      while (i !== size) {\n        var key = keys[reverse ? size - ++i : i++];\n\n        if (fn(object[key], key, this) === false) {\n          break;\n        }\n      }\n\n      return i;\n    };\n\n    ObjectSeq.prototype.__iterator = function __iterator(type, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var size = keys.length;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n\n        var key = keys[reverse ? size - ++i : i++];\n        return iteratorValue(type, key, object[key]);\n      });\n    };\n\n    return ObjectSeq;\n  }(KeyedSeq);\n\n  ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;\n\n  var CollectionSeq =\n  /*@__PURE__*/\n  function (IndexedSeq) {\n    function CollectionSeq(collection) {\n      this._collection = collection;\n      this.size = collection.length || collection.size;\n    }\n\n    if (IndexedSeq) CollectionSeq.__proto__ = IndexedSeq;\n    CollectionSeq.prototype = Object.create(IndexedSeq && IndexedSeq.prototype);\n    CollectionSeq.prototype.constructor = CollectionSeq;\n\n    CollectionSeq.prototype.__iterateUncached = function __iterateUncached(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n\n      var collection = this._collection;\n      var iterator = getIterator(collection);\n      var iterations = 0;\n\n      if (isIterator(iterator)) {\n        var step;\n\n        while (!(step = iterator.next()).done) {\n          if (fn(step.value, iterations++, this) === false) {\n            break;\n          }\n        }\n      }\n\n      return iterations;\n    };\n\n    CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n\n      var collection = this._collection;\n      var iterator = getIterator(collection);\n\n      if (!isIterator(iterator)) {\n        return new Iterator(iteratorDone);\n      }\n\n      var iterations = 0;\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, iterations++, step.value);\n      });\n    };\n\n    return CollectionSeq;\n  }(IndexedSeq); // # pragma Helper functions\n\n\n  var EMPTY_SEQ;\n\n  function emptySequence() {\n    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n  }\n\n  function keyedSeqFromValue(value) {\n    var seq = Array.isArray(value) ? new ArraySeq(value) : hasIterator(value) ? new CollectionSeq(value) : undefined;\n\n    if (seq) {\n      return seq.fromEntrySeq();\n    }\n\n    if (typeof value === 'object') {\n      return new ObjectSeq(value);\n    }\n\n    throw new TypeError('Expected Array or collection object of [k, v] entries, or keyed object: ' + value);\n  }\n\n  function indexedSeqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n\n    if (seq) {\n      return seq;\n    }\n\n    throw new TypeError('Expected Array or collection object of values: ' + value);\n  }\n\n  function seqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n\n    if (seq) {\n      return seq;\n    }\n\n    if (typeof value === 'object') {\n      return new ObjectSeq(value);\n    }\n\n    throw new TypeError('Expected Array or collection object of values, or keyed object: ' + value);\n  }\n\n  function maybeIndexedSeqFromValue(value) {\n    return isArrayLike(value) ? new ArraySeq(value) : hasIterator(value) ? new CollectionSeq(value) : undefined;\n  }\n\n  var IS_MAP_SYMBOL = '@@__IMMUTABLE_MAP__@@';\n\n  function isMap(maybeMap) {\n    return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);\n  }\n\n  function isOrderedMap(maybeOrderedMap) {\n    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n  }\n\n  function isValueObject(maybeValue) {\n    return Boolean(maybeValue && typeof maybeValue.equals === 'function' && typeof maybeValue.hashCode === 'function');\n  }\n  /**\n   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n   *\n   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n   * value, which is different from the algorithm described by\n   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n   *\n   * This is extended further to allow Objects to describe the values they\n   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n   *\n   * Note: because of this extension, the key equality of Immutable.Map and the\n   * value equality of Immutable.Set will differ from ES6 Map and Set.\n   *\n   * ### Defining custom values\n   *\n   * The easiest way to describe the value an object represents is by implementing\n   * `valueOf`. For example, `Date` represents a value by returning a unix\n   * timestamp for `valueOf`:\n   *\n   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n   *     var date2 = new Date(1234567890000);\n   *     date1.valueOf(); // 1234567890000\n   *     assert( date1 !== date2 );\n   *     assert( Immutable.is( date1, date2 ) );\n   *\n   * Note: overriding `valueOf` may have other implications if you use this object\n   * where JavaScript expects a primitive, such as implicit string coercion.\n   *\n   * For more complex types, especially collections, implementing `valueOf` may\n   * not be performant. An alternative is to implement `equals` and `hashCode`.\n   *\n   * `equals` takes another object, presumably of similar type, and returns true\n   * if it is equal. Equality is symmetrical, so the same result should be\n   * returned if this and the argument are flipped.\n   *\n   *     assert( a.equals(b) === b.equals(a) );\n   *\n   * `hashCode` returns a 32bit integer number representing the object which will\n   * be used to determine how to store the value object in a Map or Set. You must\n   * provide both or neither methods, one must not exist without the other.\n   *\n   * Also, an important relationship between these methods must be upheld: if two\n   * values are equal, they *must* return the same hashCode. If the values are not\n   * equal, they might have the same hashCode; this is called a hash collision,\n   * and while undesirable for performance reasons, it is acceptable.\n   *\n   *     if (a.equals(b)) {\n   *       assert( a.hashCode() === b.hashCode() );\n   *     }\n   *\n   * All Immutable collections are Value Objects: they implement `equals()`\n   * and `hashCode()`.\n   */\n\n\n  function is(valueA, valueB) {\n    if (valueA === valueB || valueA !== valueA && valueB !== valueB) {\n      return true;\n    }\n\n    if (!valueA || !valueB) {\n      return false;\n    }\n\n    if (typeof valueA.valueOf === 'function' && typeof valueB.valueOf === 'function') {\n      valueA = valueA.valueOf();\n      valueB = valueB.valueOf();\n\n      if (valueA === valueB || valueA !== valueA && valueB !== valueB) {\n        return true;\n      }\n\n      if (!valueA || !valueB) {\n        return false;\n      }\n    }\n\n    return !!(isValueObject(valueA) && isValueObject(valueB) && valueA.equals(valueB));\n  }\n\n  var imul = typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ? Math.imul : function imul(a, b) {\n    a |= 0; // int\n\n    b |= 0; // int\n\n    var c = a & 0xffff;\n    var d = b & 0xffff; // Shift by 0 fixes the sign on the high part.\n\n    return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0; // int\n  }; // v8 has an optimization for storing 31-bit signed numbers.\n  // Values which have either 00 or 11 as the high order bits qualify.\n  // This function drops the highest order bit in a signed number, maintaining\n  // the sign bit.\n\n  function smi(i32) {\n    return i32 >>> 1 & 0x40000000 | i32 & 0xbfffffff;\n  }\n\n  var defaultValueOf = Object.prototype.valueOf;\n\n  function hash(o) {\n    switch (typeof o) {\n      case 'boolean':\n        // The hash values for built-in constants are a 1 value for each 5-byte\n        // shift region expect for the first, which encodes the value. This\n        // reduces the odds of a hash collision for these common values.\n        return o ? 0x42108421 : 0x42108420;\n\n      case 'number':\n        return hashNumber(o);\n\n      case 'string':\n        return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n\n      case 'object':\n      case 'function':\n        if (o === null) {\n          return 0x42108422;\n        }\n\n        if (typeof o.hashCode === 'function') {\n          // Drop any high bits from accidentally long hash codes.\n          return smi(o.hashCode(o));\n        }\n\n        if (o.valueOf !== defaultValueOf && typeof o.valueOf === 'function') {\n          o = o.valueOf(o);\n        }\n\n        return hashJSObj(o);\n\n      case 'undefined':\n        return 0x42108423;\n\n      default:\n        if (typeof o.toString === 'function') {\n          return hashString(o.toString());\n        }\n\n        throw new Error('Value type ' + typeof o + ' cannot be hashed.');\n    }\n  } // Compress arbitrarily large numbers into smi hashes.\n\n\n  function hashNumber(n) {\n    if (n !== n || n === Infinity) {\n      return 0;\n    }\n\n    var hash = n | 0;\n\n    if (hash !== n) {\n      hash ^= n * 0xffffffff;\n    }\n\n    while (n > 0xffffffff) {\n      n /= 0xffffffff;\n      hash ^= n;\n    }\n\n    return smi(hash);\n  }\n\n  function cachedHashString(string) {\n    var hashed = stringHashCache[string];\n\n    if (hashed === undefined) {\n      hashed = hashString(string);\n\n      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n        STRING_HASH_CACHE_SIZE = 0;\n        stringHashCache = {};\n      }\n\n      STRING_HASH_CACHE_SIZE++;\n      stringHashCache[string] = hashed;\n    }\n\n    return hashed;\n  } // http://jsperf.com/hashing-strings\n\n\n  function hashString(string) {\n    // This is the hash from JVM\n    // The hash code for a string is computed as\n    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n    // where s[i] is the ith character of the string and n is the length of\n    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n    // (exclusive) by dropping high bits.\n    var hashed = 0;\n\n    for (var ii = 0; ii < string.length; ii++) {\n      hashed = 31 * hashed + string.charCodeAt(ii) | 0;\n    }\n\n    return smi(hashed);\n  }\n\n  function hashJSObj(obj) {\n    var hashed;\n\n    if (usingWeakMap) {\n      hashed = weakMap.get(obj);\n\n      if (hashed !== undefined) {\n        return hashed;\n      }\n    }\n\n    hashed = obj[UID_HASH_KEY];\n\n    if (hashed !== undefined) {\n      return hashed;\n    }\n\n    if (!canDefineProperty) {\n      hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n\n      if (hashed !== undefined) {\n        return hashed;\n      }\n\n      hashed = getIENodeHash(obj);\n\n      if (hashed !== undefined) {\n        return hashed;\n      }\n    }\n\n    hashed = ++objHashUID;\n\n    if (objHashUID & 0x40000000) {\n      objHashUID = 0;\n    }\n\n    if (usingWeakMap) {\n      weakMap.set(obj, hashed);\n    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n      throw new Error('Non-extensible objects are not allowed as keys.');\n    } else if (canDefineProperty) {\n      Object.defineProperty(obj, UID_HASH_KEY, {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n        value: hashed\n      });\n    } else if (obj.propertyIsEnumerable !== undefined && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n      // Since we can't define a non-enumerable property on the object\n      // we'll hijack one of the less-used non-enumerable properties to\n      // save our hash on it. Since this is a function it will not show up in\n      // `JSON.stringify` which is what we want.\n      obj.propertyIsEnumerable = function () {\n        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n      };\n\n      obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;\n    } else if (obj.nodeType !== undefined) {\n      // At this point we couldn't get the IE `uniqueID` to use as a hash\n      // and we couldn't use a non-enumerable property to exploit the\n      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n      // itself.\n      obj[UID_HASH_KEY] = hashed;\n    } else {\n      throw new Error('Unable to set a non-enumerable property on object.');\n    }\n\n    return hashed;\n  } // Get references to ES5 object methods.\n\n\n  var isExtensible = Object.isExtensible; // True if Object.defineProperty works as expected. IE8 fails this test.\n\n  var canDefineProperty = function () {\n    try {\n      Object.defineProperty({}, '@', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }(); // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n  // and avoid memory leaks from the IE cloneNode bug.\n\n\n  function getIENodeHash(node) {\n    if (node && node.nodeType > 0) {\n      switch (node.nodeType) {\n        case 1:\n          // Element\n          return node.uniqueID;\n\n        case 9:\n          // Document\n          return node.documentElement && node.documentElement.uniqueID;\n      }\n    }\n  } // If possible, use a WeakMap.\n\n\n  var usingWeakMap = typeof WeakMap === 'function';\n  var weakMap;\n\n  if (usingWeakMap) {\n    weakMap = new WeakMap();\n  }\n\n  var objHashUID = 0;\n  var UID_HASH_KEY = '__immutablehash__';\n\n  if (typeof Symbol === 'function') {\n    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n  }\n\n  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n  var STRING_HASH_CACHE_MAX_SIZE = 255;\n  var STRING_HASH_CACHE_SIZE = 0;\n  var stringHashCache = {};\n\n  var ToKeyedSequence =\n  /*@__PURE__*/\n  function (KeyedSeq$$1) {\n    function ToKeyedSequence(indexed, useKeys) {\n      this._iter = indexed;\n      this._useKeys = useKeys;\n      this.size = indexed.size;\n    }\n\n    if (KeyedSeq$$1) ToKeyedSequence.__proto__ = KeyedSeq$$1;\n    ToKeyedSequence.prototype = Object.create(KeyedSeq$$1 && KeyedSeq$$1.prototype);\n    ToKeyedSequence.prototype.constructor = ToKeyedSequence;\n\n    ToKeyedSequence.prototype.get = function get(key, notSetValue) {\n      return this._iter.get(key, notSetValue);\n    };\n\n    ToKeyedSequence.prototype.has = function has(key) {\n      return this._iter.has(key);\n    };\n\n    ToKeyedSequence.prototype.valueSeq = function valueSeq() {\n      return this._iter.valueSeq();\n    };\n\n    ToKeyedSequence.prototype.reverse = function reverse() {\n      var this$1 = this;\n      var reversedSequence = reverseFactory(this, true);\n\n      if (!this._useKeys) {\n        reversedSequence.valueSeq = function () {\n          return this$1._iter.toSeq().reverse();\n        };\n      }\n\n      return reversedSequence;\n    };\n\n    ToKeyedSequence.prototype.map = function map(mapper, context) {\n      var this$1 = this;\n      var mappedSequence = mapFactory(this, mapper, context);\n\n      if (!this._useKeys) {\n        mappedSequence.valueSeq = function () {\n          return this$1._iter.toSeq().map(mapper, context);\n        };\n      }\n\n      return mappedSequence;\n    };\n\n    ToKeyedSequence.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n      return this._iter.__iterate(function (v, k) {\n        return fn(v, k, this$1);\n      }, reverse);\n    };\n\n    ToKeyedSequence.prototype.__iterator = function __iterator(type, reverse) {\n      return this._iter.__iterator(type, reverse);\n    };\n\n    return ToKeyedSequence;\n  }(KeyedSeq);\n\n  ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;\n\n  var ToIndexedSequence =\n  /*@__PURE__*/\n  function (IndexedSeq$$1) {\n    function ToIndexedSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    if (IndexedSeq$$1) ToIndexedSequence.__proto__ = IndexedSeq$$1;\n    ToIndexedSequence.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);\n    ToIndexedSequence.prototype.constructor = ToIndexedSequence;\n\n    ToIndexedSequence.prototype.includes = function includes(value) {\n      return this._iter.includes(value);\n    };\n\n    ToIndexedSequence.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n      var i = 0;\n      reverse && ensureSize(this);\n      return this._iter.__iterate(function (v) {\n        return fn(v, reverse ? this$1.size - ++i : i++, this$1);\n      }, reverse);\n    };\n\n    ToIndexedSequence.prototype.__iterator = function __iterator(type, reverse) {\n      var this$1 = this;\n\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\n      var i = 0;\n      reverse && ensureSize(this);\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, reverse ? this$1.size - ++i : i++, step.value, step);\n      });\n    };\n\n    return ToIndexedSequence;\n  }(IndexedSeq);\n\n  var ToSetSequence =\n  /*@__PURE__*/\n  function (SetSeq$$1) {\n    function ToSetSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    if (SetSeq$$1) ToSetSequence.__proto__ = SetSeq$$1;\n    ToSetSequence.prototype = Object.create(SetSeq$$1 && SetSeq$$1.prototype);\n    ToSetSequence.prototype.constructor = ToSetSequence;\n\n    ToSetSequence.prototype.has = function has(key) {\n      return this._iter.includes(key);\n    };\n\n    ToSetSequence.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n      return this._iter.__iterate(function (v) {\n        return fn(v, v, this$1);\n      }, reverse);\n    };\n\n    ToSetSequence.prototype.__iterator = function __iterator(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, step.value, step.value, step);\n      });\n    };\n\n    return ToSetSequence;\n  }(SetSeq);\n\n  var FromEntriesSequence =\n  /*@__PURE__*/\n  function (KeyedSeq$$1) {\n    function FromEntriesSequence(entries) {\n      this._iter = entries;\n      this.size = entries.size;\n    }\n\n    if (KeyedSeq$$1) FromEntriesSequence.__proto__ = KeyedSeq$$1;\n    FromEntriesSequence.prototype = Object.create(KeyedSeq$$1 && KeyedSeq$$1.prototype);\n    FromEntriesSequence.prototype.constructor = FromEntriesSequence;\n\n    FromEntriesSequence.prototype.entrySeq = function entrySeq() {\n      return this._iter.toSeq();\n    };\n\n    FromEntriesSequence.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n      return this._iter.__iterate(function (entry) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedCollection = isCollection(entry);\n          return fn(indexedCollection ? entry.get(1) : entry[1], indexedCollection ? entry.get(0) : entry[0], this$1);\n        }\n      }, reverse);\n    };\n\n    FromEntriesSequence.prototype.__iterator = function __iterator(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n\n      return new Iterator(function () {\n        while (true) {\n          var step = iterator.next();\n\n          if (step.done) {\n            return step;\n          }\n\n          var entry = step.value; // Check if entry exists first so array access doesn't throw for holes\n          // in the parent iteration.\n\n          if (entry) {\n            validateEntry(entry);\n            var indexedCollection = isCollection(entry);\n            return iteratorValue(type, indexedCollection ? entry.get(0) : entry[0], indexedCollection ? entry.get(1) : entry[1], step);\n          }\n        }\n      });\n    };\n\n    return FromEntriesSequence;\n  }(KeyedSeq);\n\n  ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;\n\n  function flipFactory(collection) {\n    var flipSequence = makeSequence(collection);\n    flipSequence._iter = collection;\n    flipSequence.size = collection.size;\n\n    flipSequence.flip = function () {\n      return collection;\n    };\n\n    flipSequence.reverse = function () {\n      var reversedSequence = collection.reverse.apply(this); // super.reverse()\n\n      reversedSequence.flip = function () {\n        return collection.reverse();\n      };\n\n      return reversedSequence;\n    };\n\n    flipSequence.has = function (key) {\n      return collection.includes(key);\n    };\n\n    flipSequence.includes = function (key) {\n      return collection.has(key);\n    };\n\n    flipSequence.cacheResult = cacheResultThrough;\n\n    flipSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n      return collection.__iterate(function (v, k) {\n        return fn(k, v, this$1) !== false;\n      }, reverse);\n    };\n\n    flipSequence.__iteratorUncached = function (type, reverse) {\n      if (type === ITERATE_ENTRIES) {\n        var iterator = collection.__iterator(type, reverse);\n\n        return new Iterator(function () {\n          var step = iterator.next();\n\n          if (!step.done) {\n            var k = step.value[0];\n            step.value[0] = step.value[1];\n            step.value[1] = k;\n          }\n\n          return step;\n        });\n      }\n\n      return collection.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse);\n    };\n\n    return flipSequence;\n  }\n\n  function mapFactory(collection, mapper, context) {\n    var mappedSequence = makeSequence(collection);\n    mappedSequence.size = collection.size;\n\n    mappedSequence.has = function (key) {\n      return collection.has(key);\n    };\n\n    mappedSequence.get = function (key, notSetValue) {\n      var v = collection.get(key, NOT_SET);\n      return v === NOT_SET ? notSetValue : mapper.call(context, v, key, collection);\n    };\n\n    mappedSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n      return collection.__iterate(function (v, k, c) {\n        return fn(mapper.call(context, v, k, c), k, this$1) !== false;\n      }, reverse);\n    };\n\n    mappedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n\n      return new Iterator(function () {\n        var step = iterator.next();\n\n        if (step.done) {\n          return step;\n        }\n\n        var entry = step.value;\n        var key = entry[0];\n        return iteratorValue(type, key, mapper.call(context, entry[1], key, collection), step);\n      });\n    };\n\n    return mappedSequence;\n  }\n\n  function reverseFactory(collection, useKeys) {\n    var this$1 = this;\n    var reversedSequence = makeSequence(collection);\n    reversedSequence._iter = collection;\n    reversedSequence.size = collection.size;\n\n    reversedSequence.reverse = function () {\n      return collection;\n    };\n\n    if (collection.flip) {\n      reversedSequence.flip = function () {\n        var flipSequence = flipFactory(collection);\n\n        flipSequence.reverse = function () {\n          return collection.flip();\n        };\n\n        return flipSequence;\n      };\n    }\n\n    reversedSequence.get = function (key, notSetValue) {\n      return collection.get(useKeys ? key : -1 - key, notSetValue);\n    };\n\n    reversedSequence.has = function (key) {\n      return collection.has(useKeys ? key : -1 - key);\n    };\n\n    reversedSequence.includes = function (value) {\n      return collection.includes(value);\n    };\n\n    reversedSequence.cacheResult = cacheResultThrough;\n\n    reversedSequence.__iterate = function (fn, reverse) {\n      var this$1 = this;\n      var i = 0;\n      reverse && ensureSize(collection);\n      return collection.__iterate(function (v, k) {\n        return fn(v, useKeys ? k : reverse ? this$1.size - ++i : i++, this$1);\n      }, !reverse);\n    };\n\n    reversedSequence.__iterator = function (type, reverse) {\n      var i = 0;\n      reverse && ensureSize(collection);\n\n      var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);\n\n      return new Iterator(function () {\n        var step = iterator.next();\n\n        if (step.done) {\n          return step;\n        }\n\n        var entry = step.value;\n        return iteratorValue(type, useKeys ? entry[0] : reverse ? this$1.size - ++i : i++, entry[1], step);\n      });\n    };\n\n    return reversedSequence;\n  }\n\n  function filterFactory(collection, predicate, context, useKeys) {\n    var filterSequence = makeSequence(collection);\n\n    if (useKeys) {\n      filterSequence.has = function (key) {\n        var v = collection.get(key, NOT_SET);\n        return v !== NOT_SET && !!predicate.call(context, v, key, collection);\n      };\n\n      filterSequence.get = function (key, notSetValue) {\n        var v = collection.get(key, NOT_SET);\n        return v !== NOT_SET && predicate.call(context, v, key, collection) ? v : notSetValue;\n      };\n    }\n\n    filterSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n      var iterations = 0;\n\n      collection.__iterate(function (v, k, c) {\n        if (predicate.call(context, v, k, c)) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$1);\n        }\n      }, reverse);\n\n      return iterations;\n    };\n\n    filterSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n\n      var iterations = 0;\n      return new Iterator(function () {\n        while (true) {\n          var step = iterator.next();\n\n          if (step.done) {\n            return step;\n          }\n\n          var entry = step.value;\n          var key = entry[0];\n          var value = entry[1];\n\n          if (predicate.call(context, value, key, collection)) {\n            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n          }\n        }\n      });\n    };\n\n    return filterSequence;\n  }\n\n  function countByFactory(collection, grouper, context) {\n    var groups = Map().asMutable();\n\n    collection.__iterate(function (v, k) {\n      groups.update(grouper.call(context, v, k, collection), 0, function (a) {\n        return a + 1;\n      });\n    });\n\n    return groups.asImmutable();\n  }\n\n  function groupByFactory(collection, grouper, context) {\n    var isKeyedIter = isKeyed(collection);\n    var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();\n\n    collection.__iterate(function (v, k) {\n      groups.update(grouper.call(context, v, k, collection), function (a) {\n        return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;\n      });\n    });\n\n    var coerce = collectionClass(collection);\n    return groups.map(function (arr) {\n      return reify(collection, coerce(arr));\n    }).asImmutable();\n  }\n\n  function sliceFactory(collection, begin, end, useKeys) {\n    var originalSize = collection.size;\n\n    if (wholeSlice(begin, end, originalSize)) {\n      return collection;\n    }\n\n    var resolvedBegin = resolveBegin(begin, originalSize);\n    var resolvedEnd = resolveEnd(end, originalSize); // begin or end will be NaN if they were provided as negative numbers and\n    // this collection's size is unknown. In that case, cache first so there is\n    // a known size and these do not resolve to NaN.\n\n    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n      return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);\n    } // Note: resolvedEnd is undefined when the original sequence's length is\n    // unknown and this slice did not supply an end and should contain all\n    // elements after resolvedBegin.\n    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n\n\n    var resolvedSize = resolvedEnd - resolvedBegin;\n    var sliceSize;\n\n    if (resolvedSize === resolvedSize) {\n      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n    }\n\n    var sliceSeq = makeSequence(collection); // If collection.size is undefined, the size of the realized sliceSeq is\n    // unknown at this point unless the number of items to slice is 0\n\n    sliceSeq.size = sliceSize === 0 ? sliceSize : collection.size && sliceSize || undefined;\n\n    if (!useKeys && isSeq(collection) && sliceSize >= 0) {\n      sliceSeq.get = function (index, notSetValue) {\n        index = wrapIndex(this, index);\n        return index >= 0 && index < sliceSize ? collection.get(index + resolvedBegin, notSetValue) : notSetValue;\n      };\n    }\n\n    sliceSeq.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      if (sliceSize === 0) {\n        return 0;\n      }\n\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n\n      var skipped = 0;\n      var isSkipping = true;\n      var iterations = 0;\n\n      collection.__iterate(function (v, k) {\n        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$1) !== false && iterations !== sliceSize;\n        }\n      });\n\n      return iterations;\n    };\n\n    sliceSeq.__iteratorUncached = function (type, reverse) {\n      if (sliceSize !== 0 && reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      } // Don't bother instantiating parent iterator if taking 0.\n\n\n      if (sliceSize === 0) {\n        return new Iterator(iteratorDone);\n      }\n\n      var iterator = collection.__iterator(type, reverse);\n\n      var skipped = 0;\n      var iterations = 0;\n      return new Iterator(function () {\n        while (skipped++ < resolvedBegin) {\n          iterator.next();\n        }\n\n        if (++iterations > sliceSize) {\n          return iteratorDone();\n        }\n\n        var step = iterator.next();\n\n        if (useKeys || type === ITERATE_VALUES || step.done) {\n          return step;\n        }\n\n        if (type === ITERATE_KEYS) {\n          return iteratorValue(type, iterations - 1, undefined, step);\n        }\n\n        return iteratorValue(type, iterations - 1, step.value[1], step);\n      });\n    };\n\n    return sliceSeq;\n  }\n\n  function takeWhileFactory(collection, predicate, context) {\n    var takeSequence = makeSequence(collection);\n\n    takeSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n\n      var iterations = 0;\n\n      collection.__iterate(function (v, k, c) {\n        return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1);\n      });\n\n      return iterations;\n    };\n\n    takeSequence.__iteratorUncached = function (type, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n\n      var iterating = true;\n      return new Iterator(function () {\n        if (!iterating) {\n          return iteratorDone();\n        }\n\n        var step = iterator.next();\n\n        if (step.done) {\n          return step;\n        }\n\n        var entry = step.value;\n        var k = entry[0];\n        var v = entry[1];\n\n        if (!predicate.call(context, v, k, this$1)) {\n          iterating = false;\n          return iteratorDone();\n        }\n\n        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n      });\n    };\n\n    return takeSequence;\n  }\n\n  function skipWhileFactory(collection, predicate, context, useKeys) {\n    var skipSequence = makeSequence(collection);\n\n    skipSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n\n      var isSkipping = true;\n      var iterations = 0;\n\n      collection.__iterate(function (v, k, c) {\n        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$1);\n        }\n      });\n\n      return iterations;\n    };\n\n    skipSequence.__iteratorUncached = function (type, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n\n      var skipping = true;\n      var iterations = 0;\n      return new Iterator(function () {\n        var step;\n        var k;\n        var v;\n\n        do {\n          step = iterator.next();\n\n          if (step.done) {\n            if (useKeys || type === ITERATE_VALUES) {\n              return step;\n            }\n\n            if (type === ITERATE_KEYS) {\n              return iteratorValue(type, iterations++, undefined, step);\n            }\n\n            return iteratorValue(type, iterations++, step.value[1], step);\n          }\n\n          var entry = step.value;\n          k = entry[0];\n          v = entry[1];\n          skipping && (skipping = predicate.call(context, v, k, this$1));\n        } while (skipping);\n\n        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n      });\n    };\n\n    return skipSequence;\n  }\n\n  function concatFactory(collection, values) {\n    var isKeyedCollection = isKeyed(collection);\n    var iters = [collection].concat(values).map(function (v) {\n      if (!isCollection(v)) {\n        v = isKeyedCollection ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n      } else if (isKeyedCollection) {\n        v = KeyedCollection(v);\n      }\n\n      return v;\n    }).filter(function (v) {\n      return v.size !== 0;\n    });\n\n    if (iters.length === 0) {\n      return collection;\n    }\n\n    if (iters.length === 1) {\n      var singleton = iters[0];\n\n      if (singleton === collection || isKeyedCollection && isKeyed(singleton) || isIndexed(collection) && isIndexed(singleton)) {\n        return singleton;\n      }\n    }\n\n    var concatSeq = new ArraySeq(iters);\n\n    if (isKeyedCollection) {\n      concatSeq = concatSeq.toKeyedSeq();\n    } else if (!isIndexed(collection)) {\n      concatSeq = concatSeq.toSetSeq();\n    }\n\n    concatSeq = concatSeq.flatten(true);\n    concatSeq.size = iters.reduce(function (sum, seq) {\n      if (sum !== undefined) {\n        var size = seq.size;\n\n        if (size !== undefined) {\n          return sum + size;\n        }\n      }\n    }, 0);\n    return concatSeq;\n  }\n\n  function flattenFactory(collection, depth, useKeys) {\n    var flatSequence = makeSequence(collection);\n\n    flatSequence.__iterateUncached = function (fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n\n      var iterations = 0;\n      var stopped = false;\n\n      function flatDeep(iter, currentDepth) {\n        iter.__iterate(function (v, k) {\n          if ((!depth || currentDepth < depth) && isCollection(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else {\n            iterations++;\n\n            if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {\n              stopped = true;\n            }\n          }\n\n          return !stopped;\n        }, reverse);\n      }\n\n      flatDeep(collection, 0);\n      return iterations;\n    };\n\n    flatSequence.__iteratorUncached = function (type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n\n      var iterator = collection.__iterator(type, reverse);\n\n      var stack = [];\n      var iterations = 0;\n      return new Iterator(function () {\n        while (iterator) {\n          var step = iterator.next();\n\n          if (step.done !== false) {\n            iterator = stack.pop();\n            continue;\n          }\n\n          var v = step.value;\n\n          if (type === ITERATE_ENTRIES) {\n            v = v[1];\n          }\n\n          if ((!depth || stack.length < depth) && isCollection(v)) {\n            stack.push(iterator);\n            iterator = v.__iterator(type, reverse);\n          } else {\n            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n          }\n        }\n\n        return iteratorDone();\n      });\n    };\n\n    return flatSequence;\n  }\n\n  function flatMapFactory(collection, mapper, context) {\n    var coerce = collectionClass(collection);\n    return collection.toSeq().map(function (v, k) {\n      return coerce(mapper.call(context, v, k, collection));\n    }).flatten(true);\n  }\n\n  function interposeFactory(collection, separator) {\n    var interposedSequence = makeSequence(collection);\n    interposedSequence.size = collection.size && collection.size * 2 - 1;\n\n    interposedSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n      var iterations = 0;\n\n      collection.__iterate(function (v) {\n        return (!iterations || fn(separator, iterations++, this$1) !== false) && fn(v, iterations++, this$1) !== false;\n      }, reverse);\n\n      return iterations;\n    };\n\n    interposedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = collection.__iterator(ITERATE_VALUES, reverse);\n\n      var iterations = 0;\n      var step;\n      return new Iterator(function () {\n        if (!step || iterations % 2) {\n          step = iterator.next();\n\n          if (step.done) {\n            return step;\n          }\n        }\n\n        return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);\n      });\n    };\n\n    return interposedSequence;\n  }\n\n  function sortFactory(collection, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n\n    var isKeyedCollection = isKeyed(collection);\n    var index = 0;\n    var entries = collection.toSeq().map(function (v, k) {\n      return [k, v, index++, mapper ? mapper(v, k, collection) : v];\n    }).valueSeq().toArray();\n    entries.sort(function (a, b) {\n      return comparator(a[3], b[3]) || a[2] - b[2];\n    }).forEach(isKeyedCollection ? function (v, i) {\n      entries[i].length = 2;\n    } : function (v, i) {\n      entries[i] = v[1];\n    });\n    return isKeyedCollection ? KeyedSeq(entries) : isIndexed(collection) ? IndexedSeq(entries) : SetSeq(entries);\n  }\n\n  function maxFactory(collection, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n\n    if (mapper) {\n      var entry = collection.toSeq().map(function (v, k) {\n        return [v, mapper(v, k, collection)];\n      }).reduce(function (a, b) {\n        return maxCompare(comparator, a[1], b[1]) ? b : a;\n      });\n      return entry && entry[0];\n    }\n\n    return collection.reduce(function (a, b) {\n      return maxCompare(comparator, a, b) ? b : a;\n    });\n  }\n\n  function maxCompare(comparator, a, b) {\n    var comp = comparator(b, a); // b is considered the new max if the comparator declares them equal, but\n    // they are not equal and b is in fact a nullish value.\n\n    return comp === 0 && b !== a && (b === undefined || b === null || b !== b) || comp > 0;\n  }\n\n  function zipWithFactory(keyIter, zipper, iters, zipAll) {\n    var zipSequence = makeSequence(keyIter);\n    var sizes = new ArraySeq(iters).map(function (i) {\n      return i.size;\n    });\n    zipSequence.size = zipAll ? sizes.max() : sizes.min(); // Note: this a generic base implementation of __iterate in terms of\n    // __iterator which may be more generically useful in the future.\n\n    zipSequence.__iterate = function (fn, reverse) {\n      /* generic:\n      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        iterations++;\n        if (fn(step.value[1], step.value[0], this) === false) {\n          break;\n        }\n      }\n      return iterations;\n      */\n      // indexed:\n      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n\n      var step;\n      var iterations = 0;\n\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n\n      return iterations;\n    };\n\n    zipSequence.__iteratorUncached = function (type, reverse) {\n      var iterators = iters.map(function (i) {\n        return i = Collection(i), getIterator(reverse ? i.reverse() : i);\n      });\n      var iterations = 0;\n      var isDone = false;\n      return new Iterator(function () {\n        var steps;\n\n        if (!isDone) {\n          steps = iterators.map(function (i) {\n            return i.next();\n          });\n          isDone = zipAll ? steps.every(function (s) {\n            return s.done;\n          }) : steps.some(function (s) {\n            return s.done;\n          });\n        }\n\n        if (isDone) {\n          return iteratorDone();\n        }\n\n        return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function (s) {\n          return s.value;\n        })));\n      });\n    };\n\n    return zipSequence;\n  } // #pragma Helper Functions\n\n\n  function reify(iter, seq) {\n    return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);\n  }\n\n  function validateEntry(entry) {\n    if (entry !== Object(entry)) {\n      throw new TypeError('Expected [K, V] tuple: ' + entry);\n    }\n  }\n\n  function collectionClass(collection) {\n    return isKeyed(collection) ? KeyedCollection : isIndexed(collection) ? IndexedCollection : SetCollection;\n  }\n\n  function makeSequence(collection) {\n    return Object.create((isKeyed(collection) ? KeyedSeq : isIndexed(collection) ? IndexedSeq : SetSeq).prototype);\n  }\n\n  function cacheResultThrough() {\n    if (this._iter.cacheResult) {\n      this._iter.cacheResult();\n\n      this.size = this._iter.size;\n      return this;\n    }\n\n    return Seq.prototype.cacheResult.call(this);\n  }\n\n  function defaultComparator(a, b) {\n    if (a === undefined && b === undefined) {\n      return 0;\n    }\n\n    if (a === undefined) {\n      return 1;\n    }\n\n    if (b === undefined) {\n      return -1;\n    }\n\n    return a > b ? 1 : a < b ? -1 : 0;\n  } // http://jsperf.com/copy-array-inline\n\n\n  function arrCopy(arr, offset) {\n    offset = offset || 0;\n    var len = Math.max(0, arr.length - offset);\n    var newArr = new Array(len);\n\n    for (var ii = 0; ii < len; ii++) {\n      newArr[ii] = arr[ii + offset];\n    }\n\n    return newArr;\n  }\n\n  function invariant(condition, error) {\n    if (!condition) {\n      throw new Error(error);\n    }\n  }\n\n  function assertNotInfinite(size) {\n    invariant(size !== Infinity, 'Cannot perform this action with an infinite size.');\n  }\n\n  function coerceKeyPath(keyPath) {\n    if (isArrayLike(keyPath) && typeof keyPath !== 'string') {\n      return keyPath;\n    }\n\n    if (isOrdered(keyPath)) {\n      return keyPath.toArray();\n    }\n\n    throw new TypeError('Invalid keyPath: expected Ordered Collection or Array: ' + keyPath);\n  }\n\n  function isPlainObj(value) {\n    return value && (typeof value.constructor !== 'function' || value.constructor.name === 'Object');\n  }\n  /**\n   * Returns true if the value is a potentially-persistent data structure, either\n   * provided by Immutable.js or a plain Array or Object.\n   */\n\n\n  function isDataStructure(value) {\n    return typeof value === 'object' && (isImmutable(value) || Array.isArray(value) || isPlainObj(value));\n  }\n  /**\n   * Converts a value to a string, adding quotes if a string was provided.\n   */\n\n\n  function quoteString(value) {\n    try {\n      return typeof value === 'string' ? JSON.stringify(value) : String(value);\n    } catch (_ignoreError) {\n      return JSON.stringify(value);\n    }\n  }\n\n  function has(collection, key) {\n    return isImmutable(collection) ? collection.has(key) : isDataStructure(collection) && hasOwnProperty.call(collection, key);\n  }\n\n  function get(collection, key, notSetValue) {\n    return isImmutable(collection) ? collection.get(key, notSetValue) : !has(collection, key) ? notSetValue : typeof collection.get === 'function' ? collection.get(key) : collection[key];\n  }\n\n  function shallowCopy(from) {\n    if (Array.isArray(from)) {\n      return arrCopy(from);\n    }\n\n    var to = {};\n\n    for (var key in from) {\n      if (hasOwnProperty.call(from, key)) {\n        to[key] = from[key];\n      }\n    }\n\n    return to;\n  }\n\n  function remove(collection, key) {\n    if (!isDataStructure(collection)) {\n      throw new TypeError('Cannot update non-data-structure value: ' + collection);\n    }\n\n    if (isImmutable(collection)) {\n      if (!collection.remove) {\n        throw new TypeError('Cannot update immutable value without .remove() method: ' + collection);\n      }\n\n      return collection.remove(key);\n    }\n\n    if (!hasOwnProperty.call(collection, key)) {\n      return collection;\n    }\n\n    var collectionCopy = shallowCopy(collection);\n\n    if (Array.isArray(collectionCopy)) {\n      collectionCopy.splice(key, 1);\n    } else {\n      delete collectionCopy[key];\n    }\n\n    return collectionCopy;\n  }\n\n  function set(collection, key, value) {\n    if (!isDataStructure(collection)) {\n      throw new TypeError('Cannot update non-data-structure value: ' + collection);\n    }\n\n    if (isImmutable(collection)) {\n      if (!collection.set) {\n        throw new TypeError('Cannot update immutable value without .set() method: ' + collection);\n      }\n\n      return collection.set(key, value);\n    }\n\n    if (hasOwnProperty.call(collection, key) && value === collection[key]) {\n      return collection;\n    }\n\n    var collectionCopy = shallowCopy(collection);\n    collectionCopy[key] = value;\n    return collectionCopy;\n  }\n\n  function updateIn(collection, keyPath, notSetValue, updater) {\n    if (!updater) {\n      updater = notSetValue;\n      notSetValue = undefined;\n    }\n\n    var updatedValue = updateInDeeply(isImmutable(collection), collection, coerceKeyPath(keyPath), 0, notSetValue, updater);\n    return updatedValue === NOT_SET ? notSetValue : updatedValue;\n  }\n\n  function updateInDeeply(inImmutable, existing, keyPath, i, notSetValue, updater) {\n    var wasNotSet = existing === NOT_SET;\n\n    if (i === keyPath.length) {\n      var existingValue = wasNotSet ? notSetValue : existing;\n      var newValue = updater(existingValue);\n      return newValue === existingValue ? existing : newValue;\n    }\n\n    if (!wasNotSet && !isDataStructure(existing)) {\n      throw new TypeError('Cannot update within non-data-structure value in path [' + keyPath.slice(0, i).map(quoteString) + ']: ' + existing);\n    }\n\n    var key = keyPath[i];\n    var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);\n    var nextUpdated = updateInDeeply(nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting), nextExisting, keyPath, i + 1, notSetValue, updater);\n    return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? remove(existing, key) : set(wasNotSet ? inImmutable ? emptyMap() : {} : existing, key, nextUpdated);\n  }\n\n  function setIn(collection, keyPath, value) {\n    return updateIn(collection, keyPath, NOT_SET, function () {\n      return value;\n    });\n  }\n\n  function setIn$1(keyPath, v) {\n    return setIn(this, keyPath, v);\n  }\n\n  function removeIn(collection, keyPath) {\n    return updateIn(collection, keyPath, function () {\n      return NOT_SET;\n    });\n  }\n\n  function deleteIn(keyPath) {\n    return removeIn(this, keyPath);\n  }\n\n  function update(collection, key, notSetValue, updater) {\n    return updateIn(collection, [key], notSetValue, updater);\n  }\n\n  function update$1(key, notSetValue, updater) {\n    return arguments.length === 1 ? key(this) : update(this, key, notSetValue, updater);\n  }\n\n  function updateIn$1(keyPath, notSetValue, updater) {\n    return updateIn(this, keyPath, notSetValue, updater);\n  }\n\n  function merge() {\n    var iters = [],\n        len = arguments.length;\n\n    while (len--) iters[len] = arguments[len];\n\n    return mergeIntoKeyedWith(this, iters);\n  }\n\n  function mergeWith(merger) {\n    var iters = [],\n        len = arguments.length - 1;\n\n    while (len-- > 0) iters[len] = arguments[len + 1];\n\n    if (typeof merger !== 'function') {\n      throw new TypeError('Invalid merger function: ' + merger);\n    }\n\n    return mergeIntoKeyedWith(this, iters, merger);\n  }\n\n  function mergeIntoKeyedWith(collection, collections, merger) {\n    var iters = [];\n\n    for (var ii = 0; ii < collections.length; ii++) {\n      var collection$1 = KeyedCollection(collections[ii]);\n\n      if (collection$1.size !== 0) {\n        iters.push(collection$1);\n      }\n    }\n\n    if (iters.length === 0) {\n      return collection;\n    }\n\n    if (collection.toSeq().size === 0 && !collection.__ownerID && iters.length === 1) {\n      return collection.constructor(iters[0]);\n    }\n\n    return collection.withMutations(function (collection) {\n      var mergeIntoCollection = merger ? function (value, key) {\n        update(collection, key, NOT_SET, function (oldVal) {\n          return oldVal === NOT_SET ? value : merger(oldVal, value, key);\n        });\n      } : function (value, key) {\n        collection.set(key, value);\n      };\n\n      for (var ii = 0; ii < iters.length; ii++) {\n        iters[ii].forEach(mergeIntoCollection);\n      }\n    });\n  }\n\n  function merge$1(collection) {\n    var sources = [],\n        len = arguments.length - 1;\n\n    while (len-- > 0) sources[len] = arguments[len + 1];\n\n    return mergeWithSources(collection, sources);\n  }\n\n  function mergeWith$1(merger, collection) {\n    var sources = [],\n        len = arguments.length - 2;\n\n    while (len-- > 0) sources[len] = arguments[len + 2];\n\n    return mergeWithSources(collection, sources, merger);\n  }\n\n  function mergeDeep(collection) {\n    var sources = [],\n        len = arguments.length - 1;\n\n    while (len-- > 0) sources[len] = arguments[len + 1];\n\n    return mergeDeepWithSources(collection, sources);\n  }\n\n  function mergeDeepWith(merger, collection) {\n    var sources = [],\n        len = arguments.length - 2;\n\n    while (len-- > 0) sources[len] = arguments[len + 2];\n\n    return mergeDeepWithSources(collection, sources, merger);\n  }\n\n  function mergeDeepWithSources(collection, sources, merger) {\n    return mergeWithSources(collection, sources, deepMergerWith(merger));\n  }\n\n  function mergeWithSources(collection, sources, merger) {\n    if (!isDataStructure(collection)) {\n      throw new TypeError('Cannot merge into non-data-structure value: ' + collection);\n    }\n\n    if (isImmutable(collection)) {\n      return typeof merger === 'function' && collection.mergeWith ? collection.mergeWith.apply(collection, [merger].concat(sources)) : collection.merge ? collection.merge.apply(collection, sources) : collection.concat.apply(collection, sources);\n    }\n\n    var isArray = Array.isArray(collection);\n    var merged = collection;\n    var Collection$$1 = isArray ? IndexedCollection : KeyedCollection;\n    var mergeItem = isArray ? function (value) {\n      // Copy on write\n      if (merged === collection) {\n        merged = shallowCopy(merged);\n      }\n\n      merged.push(value);\n    } : function (value, key) {\n      var hasVal = hasOwnProperty.call(merged, key);\n      var nextVal = hasVal && merger ? merger(merged[key], value, key) : value;\n\n      if (!hasVal || nextVal !== merged[key]) {\n        // Copy on write\n        if (merged === collection) {\n          merged = shallowCopy(merged);\n        }\n\n        merged[key] = nextVal;\n      }\n    };\n\n    for (var i = 0; i < sources.length; i++) {\n      Collection$$1(sources[i]).forEach(mergeItem);\n    }\n\n    return merged;\n  }\n\n  function deepMergerWith(merger) {\n    function deepMerger(oldValue, newValue, key) {\n      return isDataStructure(oldValue) && isDataStructure(newValue) ? mergeWithSources(oldValue, [newValue], deepMerger) : merger ? merger(oldValue, newValue, key) : newValue;\n    }\n\n    return deepMerger;\n  }\n\n  function mergeDeep$1() {\n    var iters = [],\n        len = arguments.length;\n\n    while (len--) iters[len] = arguments[len];\n\n    return mergeDeepWithSources(this, iters);\n  }\n\n  function mergeDeepWith$1(merger) {\n    var iters = [],\n        len = arguments.length - 1;\n\n    while (len-- > 0) iters[len] = arguments[len + 1];\n\n    return mergeDeepWithSources(this, iters, merger);\n  }\n\n  function mergeIn(keyPath) {\n    var iters = [],\n        len = arguments.length - 1;\n\n    while (len-- > 0) iters[len] = arguments[len + 1];\n\n    return updateIn(this, keyPath, emptyMap(), function (m) {\n      return mergeWithSources(m, iters);\n    });\n  }\n\n  function mergeDeepIn(keyPath) {\n    var iters = [],\n        len = arguments.length - 1;\n\n    while (len-- > 0) iters[len] = arguments[len + 1];\n\n    return updateIn(this, keyPath, emptyMap(), function (m) {\n      return mergeDeepWithSources(m, iters);\n    });\n  }\n\n  function withMutations(fn) {\n    var mutable = this.asMutable();\n    fn(mutable);\n    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n  }\n\n  function asMutable() {\n    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n  }\n\n  function asImmutable() {\n    return this.__ensureOwner();\n  }\n\n  function wasAltered() {\n    return this.__altered;\n  }\n\n  var Map =\n  /*@__PURE__*/\n  function (KeyedCollection$$1) {\n    function Map(value) {\n      return value === null || value === undefined ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function (map) {\n        var iter = KeyedCollection$$1(value);\n        assertNotInfinite(iter.size);\n        iter.forEach(function (v, k) {\n          return map.set(k, v);\n        });\n      });\n    }\n\n    if (KeyedCollection$$1) Map.__proto__ = KeyedCollection$$1;\n    Map.prototype = Object.create(KeyedCollection$$1 && KeyedCollection$$1.prototype);\n    Map.prototype.constructor = Map;\n\n    Map.of = function of() {\n      var keyValues = [],\n          len = arguments.length;\n\n      while (len--) keyValues[len] = arguments[len];\n\n      return emptyMap().withMutations(function (map) {\n        for (var i = 0; i < keyValues.length; i += 2) {\n          if (i + 1 >= keyValues.length) {\n            throw new Error('Missing value for key: ' + keyValues[i]);\n          }\n\n          map.set(keyValues[i], keyValues[i + 1]);\n        }\n      });\n    };\n\n    Map.prototype.toString = function toString() {\n      return this.__toString('Map {', '}');\n    }; // @pragma Access\n\n\n    Map.prototype.get = function get(k, notSetValue) {\n      return this._root ? this._root.get(0, undefined, k, notSetValue) : notSetValue;\n    }; // @pragma Modification\n\n\n    Map.prototype.set = function set(k, v) {\n      return updateMap(this, k, v);\n    };\n\n    Map.prototype.remove = function remove(k) {\n      return updateMap(this, k, NOT_SET);\n    };\n\n    Map.prototype.deleteAll = function deleteAll(keys) {\n      var collection = Collection(keys);\n\n      if (collection.size === 0) {\n        return this;\n      }\n\n      return this.withMutations(function (map) {\n        collection.forEach(function (key) {\n          return map.remove(key);\n        });\n      });\n    };\n\n    Map.prototype.clear = function clear() {\n      if (this.size === 0) {\n        return this;\n      }\n\n      if (this.__ownerID) {\n        this.size = 0;\n        this._root = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n\n      return emptyMap();\n    }; // @pragma Composition\n\n\n    Map.prototype.sort = function sort(comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator));\n    };\n\n    Map.prototype.sortBy = function sortBy(mapper, comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator, mapper));\n    };\n\n    Map.prototype.map = function map(mapper, context) {\n      return this.withMutations(function (map) {\n        map.forEach(function (value, key) {\n          map.set(key, mapper.call(context, value, key, map));\n        });\n      });\n    }; // @pragma Mutability\n\n\n    Map.prototype.__iterator = function __iterator(type, reverse) {\n      return new MapIterator(this, type, reverse);\n    };\n\n    Map.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n      var iterations = 0;\n      this._root && this._root.iterate(function (entry) {\n        iterations++;\n        return fn(entry[1], entry[0], this$1);\n      }, reverse);\n      return iterations;\n    };\n\n    Map.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyMap();\n        }\n\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n\n      return makeMap(this.size, this._root, ownerID, this.__hash);\n    };\n\n    return Map;\n  }(KeyedCollection);\n\n  Map.isMap = isMap;\n  var MapPrototype = Map.prototype;\n  MapPrototype[IS_MAP_SYMBOL] = true;\n  MapPrototype[DELETE] = MapPrototype.remove;\n  MapPrototype.removeAll = MapPrototype.deleteAll;\n  MapPrototype.setIn = setIn$1;\n  MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;\n  MapPrototype.update = update$1;\n  MapPrototype.updateIn = updateIn$1;\n  MapPrototype.merge = MapPrototype.concat = merge;\n  MapPrototype.mergeWith = mergeWith;\n  MapPrototype.mergeDeep = mergeDeep$1;\n  MapPrototype.mergeDeepWith = mergeDeepWith$1;\n  MapPrototype.mergeIn = mergeIn;\n  MapPrototype.mergeDeepIn = mergeDeepIn;\n  MapPrototype.withMutations = withMutations;\n  MapPrototype.wasAltered = wasAltered;\n  MapPrototype.asImmutable = asImmutable;\n  MapPrototype['@@transducer/init'] = MapPrototype.asMutable = asMutable;\n\n  MapPrototype['@@transducer/step'] = function (result, arr) {\n    return result.set(arr[0], arr[1]);\n  };\n\n  MapPrototype['@@transducer/result'] = function (obj) {\n    return obj.asImmutable();\n  }; // #pragma Trie Nodes\n\n\n  var ArrayMapNode = function ArrayMapNode(ownerID, entries) {\n    this.ownerID = ownerID;\n    this.entries = entries;\n  };\n\n  ArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n    var entries = this.entries;\n\n    for (var ii = 0, len = entries.length; ii < len; ii++) {\n      if (is(key, entries[ii][0])) {\n        return entries[ii][1];\n      }\n    }\n\n    return notSetValue;\n  };\n\n  ArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    var removed = value === NOT_SET;\n    var entries = this.entries;\n    var idx = 0;\n    var len = entries.length;\n\n    for (; idx < len; idx++) {\n      if (is(key, entries[idx][0])) {\n        break;\n      }\n    }\n\n    var exists = idx < len;\n\n    if (exists ? entries[idx][1] === value : removed) {\n      return this;\n    }\n\n    SetRef(didAlter);\n    (removed || !exists) && SetRef(didChangeSize);\n\n    if (removed && entries.length === 1) {\n      return; // undefined\n    }\n\n    if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n      return createNodes(ownerID, entries, key, value);\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newEntries = isEditable ? entries : arrCopy(entries);\n\n    if (exists) {\n      if (removed) {\n        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();\n      } else {\n        newEntries[idx] = [key, value];\n      }\n    } else {\n      newEntries.push([key, value]);\n    }\n\n    if (isEditable) {\n      this.entries = newEntries;\n      return this;\n    }\n\n    return new ArrayMapNode(ownerID, newEntries);\n  };\n\n  var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {\n    this.ownerID = ownerID;\n    this.bitmap = bitmap;\n    this.nodes = nodes;\n  };\n\n  BitmapIndexedNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n\n    var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);\n    var bitmap = this.bitmap;\n    return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);\n  };\n\n  BitmapIndexedNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n\n    var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var bit = 1 << keyHashFrag;\n    var bitmap = this.bitmap;\n    var exists = (bitmap & bit) !== 0;\n\n    if (!exists && value === NOT_SET) {\n      return this;\n    }\n\n    var idx = popCount(bitmap & bit - 1);\n    var nodes = this.nodes;\n    var node = exists ? nodes[idx] : undefined;\n    var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\n    if (newNode === node) {\n      return this;\n    }\n\n    if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n      return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n    }\n\n    if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n      return nodes[idx ^ 1];\n    }\n\n    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n      return newNode;\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n    var newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);\n\n    if (isEditable) {\n      this.bitmap = newBitmap;\n      this.nodes = newNodes;\n      return this;\n    }\n\n    return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n  };\n\n  var HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {\n    this.ownerID = ownerID;\n    this.count = count;\n    this.nodes = nodes;\n  };\n\n  HashArrayMapNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n\n    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var node = this.nodes[idx];\n    return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n  };\n\n  HashArrayMapNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n\n    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var removed = value === NOT_SET;\n    var nodes = this.nodes;\n    var node = nodes[idx];\n\n    if (removed && !node) {\n      return this;\n    }\n\n    var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\n    if (newNode === node) {\n      return this;\n    }\n\n    var newCount = this.count;\n\n    if (!node) {\n      newCount++;\n    } else if (!newNode) {\n      newCount--;\n\n      if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n        return packNodes(ownerID, nodes, newCount, idx);\n      }\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newNodes = setAt(nodes, idx, newNode, isEditable);\n\n    if (isEditable) {\n      this.count = newCount;\n      this.nodes = newNodes;\n      return this;\n    }\n\n    return new HashArrayMapNode(ownerID, newCount, newNodes);\n  };\n\n  var HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {\n    this.ownerID = ownerID;\n    this.keyHash = keyHash;\n    this.entries = entries;\n  };\n\n  HashCollisionNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n    var entries = this.entries;\n\n    for (var ii = 0, len = entries.length; ii < len; ii++) {\n      if (is(key, entries[ii][0])) {\n        return entries[ii][1];\n      }\n    }\n\n    return notSetValue;\n  };\n\n  HashCollisionNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n\n    var removed = value === NOT_SET;\n\n    if (keyHash !== this.keyHash) {\n      if (removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n    }\n\n    var entries = this.entries;\n    var idx = 0;\n    var len = entries.length;\n\n    for (; idx < len; idx++) {\n      if (is(key, entries[idx][0])) {\n        break;\n      }\n    }\n\n    var exists = idx < len;\n\n    if (exists ? entries[idx][1] === value : removed) {\n      return this;\n    }\n\n    SetRef(didAlter);\n    (removed || !exists) && SetRef(didChangeSize);\n\n    if (removed && len === 2) {\n      return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newEntries = isEditable ? entries : arrCopy(entries);\n\n    if (exists) {\n      if (removed) {\n        idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();\n      } else {\n        newEntries[idx] = [key, value];\n      }\n    } else {\n      newEntries.push([key, value]);\n    }\n\n    if (isEditable) {\n      this.entries = newEntries;\n      return this;\n    }\n\n    return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n  };\n\n  var ValueNode = function ValueNode(ownerID, keyHash, entry) {\n    this.ownerID = ownerID;\n    this.keyHash = keyHash;\n    this.entry = entry;\n  };\n\n  ValueNode.prototype.get = function get(shift, keyHash, key, notSetValue) {\n    return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n  };\n\n  ValueNode.prototype.update = function update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    var removed = value === NOT_SET;\n    var keyMatch = is(key, this.entry[0]);\n\n    if (keyMatch ? value === this.entry[1] : removed) {\n      return this;\n    }\n\n    SetRef(didAlter);\n\n    if (removed) {\n      SetRef(didChangeSize);\n      return; // undefined\n    }\n\n    if (keyMatch) {\n      if (ownerID && ownerID === this.ownerID) {\n        this.entry[1] = value;\n        return this;\n      }\n\n      return new ValueNode(ownerID, this.keyHash, [key, value]);\n    }\n\n    SetRef(didChangeSize);\n    return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n  }; // #pragma Iterators\n\n\n  ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function (fn, reverse) {\n    var entries = this.entries;\n\n    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n        return false;\n      }\n    }\n  };\n\n  BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n    var nodes = this.nodes;\n\n    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n      var node = nodes[reverse ? maxIndex - ii : ii];\n\n      if (node && node.iterate(fn, reverse) === false) {\n        return false;\n      }\n    }\n  }; // eslint-disable-next-line no-unused-vars\n\n\n  ValueNode.prototype.iterate = function (fn, reverse) {\n    return fn(this.entry);\n  };\n\n  var MapIterator =\n  /*@__PURE__*/\n  function (Iterator$$1) {\n    function MapIterator(map, type, reverse) {\n      this._type = type;\n      this._reverse = reverse;\n      this._stack = map._root && mapIteratorFrame(map._root);\n    }\n\n    if (Iterator$$1) MapIterator.__proto__ = Iterator$$1;\n    MapIterator.prototype = Object.create(Iterator$$1 && Iterator$$1.prototype);\n    MapIterator.prototype.constructor = MapIterator;\n\n    MapIterator.prototype.next = function next() {\n      var type = this._type;\n      var stack = this._stack;\n\n      while (stack) {\n        var node = stack.node;\n        var index = stack.index++;\n        var maxIndex = void 0;\n\n        if (node.entry) {\n          if (index === 0) {\n            return mapIteratorValue(type, node.entry);\n          }\n        } else if (node.entries) {\n          maxIndex = node.entries.length - 1;\n\n          if (index <= maxIndex) {\n            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n          }\n        } else {\n          maxIndex = node.nodes.length - 1;\n\n          if (index <= maxIndex) {\n            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n\n            if (subNode) {\n              if (subNode.entry) {\n                return mapIteratorValue(type, subNode.entry);\n              }\n\n              stack = this._stack = mapIteratorFrame(subNode, stack);\n            }\n\n            continue;\n          }\n        }\n\n        stack = this._stack = this._stack.__prev;\n      }\n\n      return iteratorDone();\n    };\n\n    return MapIterator;\n  }(Iterator);\n\n  function mapIteratorValue(type, entry) {\n    return iteratorValue(type, entry[0], entry[1]);\n  }\n\n  function mapIteratorFrame(node, prev) {\n    return {\n      node: node,\n      index: 0,\n      __prev: prev\n    };\n  }\n\n  function makeMap(size, root, ownerID, hash$$1) {\n    var map = Object.create(MapPrototype);\n    map.size = size;\n    map._root = root;\n    map.__ownerID = ownerID;\n    map.__hash = hash$$1;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_MAP;\n\n  function emptyMap() {\n    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n  }\n\n  function updateMap(map, k, v) {\n    var newRoot;\n    var newSize;\n\n    if (!map._root) {\n      if (v === NOT_SET) {\n        return map;\n      }\n\n      newSize = 1;\n      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n    } else {\n      var didChangeSize = MakeRef();\n      var didAlter = MakeRef();\n      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n\n      if (!didAlter.value) {\n        return map;\n      }\n\n      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n    }\n\n    if (map.__ownerID) {\n      map.size = newSize;\n      map._root = newRoot;\n      map.__hash = undefined;\n      map.__altered = true;\n      return map;\n    }\n\n    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n  }\n\n  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (!node) {\n      if (value === NOT_SET) {\n        return node;\n      }\n\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return new ValueNode(ownerID, keyHash, [key, value]);\n    }\n\n    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n  }\n\n  function isLeafNode(node) {\n    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n  }\n\n  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n    if (node.keyHash === keyHash) {\n      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n    }\n\n    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var newNode;\n    var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n    return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);\n  }\n\n  function createNodes(ownerID, entries, key, value) {\n    if (!ownerID) {\n      ownerID = new OwnerID();\n    }\n\n    var node = new ValueNode(ownerID, hash(key), [key, value]);\n\n    for (var ii = 0; ii < entries.length; ii++) {\n      var entry = entries[ii];\n      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n    }\n\n    return node;\n  }\n\n  function packNodes(ownerID, nodes, count, excluding) {\n    var bitmap = 0;\n    var packedII = 0;\n    var packedNodes = new Array(count);\n\n    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n      var node = nodes[ii];\n\n      if (node !== undefined && ii !== excluding) {\n        bitmap |= bit;\n        packedNodes[packedII++] = node;\n      }\n    }\n\n    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n  }\n\n  function expandNodes(ownerID, nodes, bitmap, including, node) {\n    var count = 0;\n    var expandedNodes = new Array(SIZE);\n\n    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n    }\n\n    expandedNodes[including] = node;\n    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n  }\n\n  function popCount(x) {\n    x -= x >> 1 & 0x55555555;\n    x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n    x = x + (x >> 4) & 0x0f0f0f0f;\n    x += x >> 8;\n    x += x >> 16;\n    return x & 0x7f;\n  }\n\n  function setAt(array, idx, val, canEdit) {\n    var newArray = canEdit ? array : arrCopy(array);\n    newArray[idx] = val;\n    return newArray;\n  }\n\n  function spliceIn(array, idx, val, canEdit) {\n    var newLen = array.length + 1;\n\n    if (canEdit && idx + 1 === newLen) {\n      array[idx] = val;\n      return array;\n    }\n\n    var newArray = new Array(newLen);\n    var after = 0;\n\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        newArray[ii] = val;\n        after = -1;\n      } else {\n        newArray[ii] = array[ii + after];\n      }\n    }\n\n    return newArray;\n  }\n\n  function spliceOut(array, idx, canEdit) {\n    var newLen = array.length - 1;\n\n    if (canEdit && idx === newLen) {\n      array.pop();\n      return array;\n    }\n\n    var newArray = new Array(newLen);\n    var after = 0;\n\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        after = 1;\n      }\n\n      newArray[ii] = array[ii + after];\n    }\n\n    return newArray;\n  }\n\n  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n  var IS_LIST_SYMBOL = '@@__IMMUTABLE_LIST__@@';\n\n  function isList(maybeList) {\n    return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);\n  }\n\n  var List =\n  /*@__PURE__*/\n  function (IndexedCollection$$1) {\n    function List(value) {\n      var empty = emptyList();\n\n      if (value === null || value === undefined) {\n        return empty;\n      }\n\n      if (isList(value)) {\n        return value;\n      }\n\n      var iter = IndexedCollection$$1(value);\n      var size = iter.size;\n\n      if (size === 0) {\n        return empty;\n      }\n\n      assertNotInfinite(size);\n\n      if (size > 0 && size < SIZE) {\n        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n      }\n\n      return empty.withMutations(function (list) {\n        list.setSize(size);\n        iter.forEach(function (v, i) {\n          return list.set(i, v);\n        });\n      });\n    }\n\n    if (IndexedCollection$$1) List.__proto__ = IndexedCollection$$1;\n    List.prototype = Object.create(IndexedCollection$$1 && IndexedCollection$$1.prototype);\n    List.prototype.constructor = List;\n\n    List.of = function of()\n    /*...values*/\n    {\n      return this(arguments);\n    };\n\n    List.prototype.toString = function toString() {\n      return this.__toString('List [', ']');\n    }; // @pragma Access\n\n\n    List.prototype.get = function get(index, notSetValue) {\n      index = wrapIndex(this, index);\n\n      if (index >= 0 && index < this.size) {\n        index += this._origin;\n        var node = listNodeFor(this, index);\n        return node && node.array[index & MASK];\n      }\n\n      return notSetValue;\n    }; // @pragma Modification\n\n\n    List.prototype.set = function set(index, value) {\n      return updateList(this, index, value);\n    };\n\n    List.prototype.remove = function remove(index) {\n      return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);\n    };\n\n    List.prototype.insert = function insert(index, value) {\n      return this.splice(index, 0, value);\n    };\n\n    List.prototype.clear = function clear() {\n      if (this.size === 0) {\n        return this;\n      }\n\n      if (this.__ownerID) {\n        this.size = this._origin = this._capacity = 0;\n        this._level = SHIFT;\n        this._root = this._tail = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n\n      return emptyList();\n    };\n\n    List.prototype.push = function push()\n    /*...values*/\n    {\n      var values = arguments;\n      var oldSize = this.size;\n      return this.withMutations(function (list) {\n        setListBounds(list, 0, oldSize + values.length);\n\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(oldSize + ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.pop = function pop() {\n      return setListBounds(this, 0, -1);\n    };\n\n    List.prototype.unshift = function unshift()\n    /*...values*/\n    {\n      var values = arguments;\n      return this.withMutations(function (list) {\n        setListBounds(list, -values.length);\n\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.shift = function shift() {\n      return setListBounds(this, 1);\n    }; // @pragma Composition\n\n\n    List.prototype.concat = function concat()\n    /*...collections*/\n    {\n      var arguments$1 = arguments;\n      var seqs = [];\n\n      for (var i = 0; i < arguments.length; i++) {\n        var argument = arguments$1[i];\n        var seq = IndexedCollection$$1(typeof argument !== 'string' && hasIterator(argument) ? argument : [argument]);\n\n        if (seq.size !== 0) {\n          seqs.push(seq);\n        }\n      }\n\n      if (seqs.length === 0) {\n        return this;\n      }\n\n      if (this.size === 0 && !this.__ownerID && seqs.length === 1) {\n        return this.constructor(seqs[0]);\n      }\n\n      return this.withMutations(function (list) {\n        seqs.forEach(function (seq) {\n          return seq.forEach(function (value) {\n            return list.push(value);\n          });\n        });\n      });\n    };\n\n    List.prototype.setSize = function setSize(size) {\n      return setListBounds(this, 0, size);\n    };\n\n    List.prototype.map = function map(mapper, context) {\n      var this$1 = this;\n      return this.withMutations(function (list) {\n        for (var i = 0; i < this$1.size; i++) {\n          list.set(i, mapper.call(context, list.get(i), i, list));\n        }\n      });\n    }; // @pragma Iteration\n\n\n    List.prototype.slice = function slice(begin, end) {\n      var size = this.size;\n\n      if (wholeSlice(begin, end, size)) {\n        return this;\n      }\n\n      return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));\n    };\n\n    List.prototype.__iterator = function __iterator(type, reverse) {\n      var index = reverse ? this.size : 0;\n      var values = iterateList(this, reverse);\n      return new Iterator(function () {\n        var value = values();\n        return value === DONE ? iteratorDone() : iteratorValue(type, reverse ? --index : index++, value);\n      });\n    };\n\n    List.prototype.__iterate = function __iterate(fn, reverse) {\n      var index = reverse ? this.size : 0;\n      var values = iterateList(this, reverse);\n      var value;\n\n      while ((value = values()) !== DONE) {\n        if (fn(value, reverse ? --index : index++, this) === false) {\n          break;\n        }\n      }\n\n      return index;\n    };\n\n    List.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyList();\n        }\n\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n\n      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n    };\n\n    return List;\n  }(IndexedCollection);\n\n  List.isList = isList;\n  var ListPrototype = List.prototype;\n  ListPrototype[IS_LIST_SYMBOL] = true;\n  ListPrototype[DELETE] = ListPrototype.remove;\n  ListPrototype.merge = ListPrototype.concat;\n  ListPrototype.setIn = setIn$1;\n  ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;\n  ListPrototype.update = update$1;\n  ListPrototype.updateIn = updateIn$1;\n  ListPrototype.mergeIn = mergeIn;\n  ListPrototype.mergeDeepIn = mergeDeepIn;\n  ListPrototype.withMutations = withMutations;\n  ListPrototype.wasAltered = wasAltered;\n  ListPrototype.asImmutable = asImmutable;\n  ListPrototype['@@transducer/init'] = ListPrototype.asMutable = asMutable;\n\n  ListPrototype['@@transducer/step'] = function (result, arr) {\n    return result.push(arr);\n  };\n\n  ListPrototype['@@transducer/result'] = function (obj) {\n    return obj.asImmutable();\n  };\n\n  var VNode = function VNode(array, ownerID) {\n    this.array = array;\n    this.ownerID = ownerID;\n  }; // TODO: seems like these methods are very similar\n\n\n  VNode.prototype.removeBefore = function removeBefore(ownerID, level, index) {\n    if (index === level ? 1 << level : this.array.length === 0) {\n      return this;\n    }\n\n    var originIndex = index >>> level & MASK;\n\n    if (originIndex >= this.array.length) {\n      return new VNode([], ownerID);\n    }\n\n    var removingFirst = originIndex === 0;\n    var newChild;\n\n    if (level > 0) {\n      var oldChild = this.array[originIndex];\n      newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n\n      if (newChild === oldChild && removingFirst) {\n        return this;\n      }\n    }\n\n    if (removingFirst && !newChild) {\n      return this;\n    }\n\n    var editable = editableVNode(this, ownerID);\n\n    if (!removingFirst) {\n      for (var ii = 0; ii < originIndex; ii++) {\n        editable.array[ii] = undefined;\n      }\n    }\n\n    if (newChild) {\n      editable.array[originIndex] = newChild;\n    }\n\n    return editable;\n  };\n\n  VNode.prototype.removeAfter = function removeAfter(ownerID, level, index) {\n    if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n      return this;\n    }\n\n    var sizeIndex = index - 1 >>> level & MASK;\n\n    if (sizeIndex >= this.array.length) {\n      return this;\n    }\n\n    var newChild;\n\n    if (level > 0) {\n      var oldChild = this.array[sizeIndex];\n      newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n\n      if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n        return this;\n      }\n    }\n\n    var editable = editableVNode(this, ownerID);\n    editable.array.splice(sizeIndex + 1);\n\n    if (newChild) {\n      editable.array[sizeIndex] = newChild;\n    }\n\n    return editable;\n  };\n\n  var DONE = {};\n\n  function iterateList(list, reverse) {\n    var left = list._origin;\n    var right = list._capacity;\n    var tailPos = getTailOffset(right);\n    var tail = list._tail;\n    return iterateNodeOrLeaf(list._root, list._level, 0);\n\n    function iterateNodeOrLeaf(node, level, offset) {\n      return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);\n    }\n\n    function iterateLeaf(node, offset) {\n      var array = offset === tailPos ? tail && tail.array : node && node.array;\n      var from = offset > left ? 0 : left - offset;\n      var to = right - offset;\n\n      if (to > SIZE) {\n        to = SIZE;\n      }\n\n      return function () {\n        if (from === to) {\n          return DONE;\n        }\n\n        var idx = reverse ? --to : from++;\n        return array && array[idx];\n      };\n    }\n\n    function iterateNode(node, level, offset) {\n      var values;\n      var array = node && node.array;\n      var from = offset > left ? 0 : left - offset >> level;\n      var to = (right - offset >> level) + 1;\n\n      if (to > SIZE) {\n        to = SIZE;\n      }\n\n      return function () {\n        while (true) {\n          if (values) {\n            var value = values();\n\n            if (value !== DONE) {\n              return value;\n            }\n\n            values = null;\n          }\n\n          if (from === to) {\n            return DONE;\n          }\n\n          var idx = reverse ? --to : from++;\n          values = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));\n        }\n      };\n    }\n  }\n\n  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n    var list = Object.create(ListPrototype);\n    list.size = capacity - origin;\n    list._origin = origin;\n    list._capacity = capacity;\n    list._level = level;\n    list._root = root;\n    list._tail = tail;\n    list.__ownerID = ownerID;\n    list.__hash = hash;\n    list.__altered = false;\n    return list;\n  }\n\n  var EMPTY_LIST;\n\n  function emptyList() {\n    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n  }\n\n  function updateList(list, index, value) {\n    index = wrapIndex(list, index);\n\n    if (index !== index) {\n      return list;\n    }\n\n    if (index >= list.size || index < 0) {\n      return list.withMutations(function (list) {\n        index < 0 ? setListBounds(list, index).set(0, value) : setListBounds(list, 0, index + 1).set(index, value);\n      });\n    }\n\n    index += list._origin;\n    var newTail = list._tail;\n    var newRoot = list._root;\n    var didAlter = MakeRef();\n\n    if (index >= getTailOffset(list._capacity)) {\n      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n    } else {\n      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n    }\n\n    if (!didAlter.value) {\n      return list;\n    }\n\n    if (list.__ownerID) {\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n\n    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n  }\n\n  function updateVNode(node, ownerID, level, index, value, didAlter) {\n    var idx = index >>> level & MASK;\n    var nodeHas = node && idx < node.array.length;\n\n    if (!nodeHas && value === undefined) {\n      return node;\n    }\n\n    var newNode;\n\n    if (level > 0) {\n      var lowerNode = node && node.array[idx];\n      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n\n      if (newLowerNode === lowerNode) {\n        return node;\n      }\n\n      newNode = editableVNode(node, ownerID);\n      newNode.array[idx] = newLowerNode;\n      return newNode;\n    }\n\n    if (nodeHas && node.array[idx] === value) {\n      return node;\n    }\n\n    if (didAlter) {\n      SetRef(didAlter);\n    }\n\n    newNode = editableVNode(node, ownerID);\n\n    if (value === undefined && idx === newNode.array.length - 1) {\n      newNode.array.pop();\n    } else {\n      newNode.array[idx] = value;\n    }\n\n    return newNode;\n  }\n\n  function editableVNode(node, ownerID) {\n    if (ownerID && node && ownerID === node.ownerID) {\n      return node;\n    }\n\n    return new VNode(node ? node.array.slice() : [], ownerID);\n  }\n\n  function listNodeFor(list, rawIndex) {\n    if (rawIndex >= getTailOffset(list._capacity)) {\n      return list._tail;\n    }\n\n    if (rawIndex < 1 << list._level + SHIFT) {\n      var node = list._root;\n      var level = list._level;\n\n      while (node && level > 0) {\n        node = node.array[rawIndex >>> level & MASK];\n        level -= SHIFT;\n      }\n\n      return node;\n    }\n  }\n\n  function setListBounds(list, begin, end) {\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin |= 0;\n    }\n\n    if (end !== undefined) {\n      end |= 0;\n    }\n\n    var owner = list.__ownerID || new OwnerID();\n    var oldOrigin = list._origin;\n    var oldCapacity = list._capacity;\n    var newOrigin = oldOrigin + begin;\n    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n\n    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n      return list;\n    } // If it's going to end after it starts, it's empty.\n\n\n    if (newOrigin >= newCapacity) {\n      return list.clear();\n    }\n\n    var newLevel = list._level;\n    var newRoot = list._root; // New origin might need creating a higher root.\n\n    var offsetShift = 0;\n\n    while (newOrigin + offsetShift < 0) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n      newLevel += SHIFT;\n      offsetShift += 1 << newLevel;\n    }\n\n    if (offsetShift) {\n      newOrigin += offsetShift;\n      oldOrigin += offsetShift;\n      newCapacity += offsetShift;\n      oldCapacity += offsetShift;\n    }\n\n    var oldTailOffset = getTailOffset(oldCapacity);\n    var newTailOffset = getTailOffset(newCapacity); // New size might need creating a higher root.\n\n    while (newTailOffset >= 1 << newLevel + SHIFT) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n      newLevel += SHIFT;\n    } // Locate or create the new tail.\n\n\n    var oldTail = list._tail;\n    var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail; // Merge Tail into tree.\n\n    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n      newRoot = editableVNode(newRoot, owner);\n      var node = newRoot;\n\n      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n        var idx = oldTailOffset >>> level & MASK;\n        node = node.array[idx] = editableVNode(node.array[idx], owner);\n      }\n\n      node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;\n    } // If the size has been reduced, there's a chance the tail needs to be trimmed.\n\n\n    if (newCapacity < oldCapacity) {\n      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n    } // If the new origin is within the tail, then we do not need a root.\n\n\n    if (newOrigin >= newTailOffset) {\n      newOrigin -= newTailOffset;\n      newCapacity -= newTailOffset;\n      newLevel = SHIFT;\n      newRoot = null;\n      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin); // Otherwise, if the root has been trimmed, garbage collect.\n    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n      offsetShift = 0; // Identify the new top root node of the subtree of the old root.\n\n      while (newRoot) {\n        var beginIndex = newOrigin >>> newLevel & MASK;\n\n        if (beginIndex !== newTailOffset >>> newLevel & MASK) {\n          break;\n        }\n\n        if (beginIndex) {\n          offsetShift += (1 << newLevel) * beginIndex;\n        }\n\n        newLevel -= SHIFT;\n        newRoot = newRoot.array[beginIndex];\n      } // Trim the new sides of the new root.\n\n\n      if (newRoot && newOrigin > oldOrigin) {\n        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n      }\n\n      if (newRoot && newTailOffset < oldTailOffset) {\n        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n      }\n\n      if (offsetShift) {\n        newOrigin -= offsetShift;\n        newCapacity -= offsetShift;\n      }\n    }\n\n    if (list.__ownerID) {\n      list.size = newCapacity - newOrigin;\n      list._origin = newOrigin;\n      list._capacity = newCapacity;\n      list._level = newLevel;\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n\n    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n  }\n\n  function getTailOffset(size) {\n    return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;\n  }\n\n  var OrderedMap =\n  /*@__PURE__*/\n  function (Map$$1) {\n    function OrderedMap(value) {\n      return value === null || value === undefined ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function (map) {\n        var iter = KeyedCollection(value);\n        assertNotInfinite(iter.size);\n        iter.forEach(function (v, k) {\n          return map.set(k, v);\n        });\n      });\n    }\n\n    if (Map$$1) OrderedMap.__proto__ = Map$$1;\n    OrderedMap.prototype = Object.create(Map$$1 && Map$$1.prototype);\n    OrderedMap.prototype.constructor = OrderedMap;\n\n    OrderedMap.of = function of()\n    /*...values*/\n    {\n      return this(arguments);\n    };\n\n    OrderedMap.prototype.toString = function toString() {\n      return this.__toString('OrderedMap {', '}');\n    }; // @pragma Access\n\n\n    OrderedMap.prototype.get = function get(k, notSetValue) {\n      var index = this._map.get(k);\n\n      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n    }; // @pragma Modification\n\n\n    OrderedMap.prototype.clear = function clear() {\n      if (this.size === 0) {\n        return this;\n      }\n\n      if (this.__ownerID) {\n        this.size = 0;\n\n        this._map.clear();\n\n        this._list.clear();\n\n        return this;\n      }\n\n      return emptyOrderedMap();\n    };\n\n    OrderedMap.prototype.set = function set(k, v) {\n      return updateOrderedMap(this, k, v);\n    };\n\n    OrderedMap.prototype.remove = function remove(k) {\n      return updateOrderedMap(this, k, NOT_SET);\n    };\n\n    OrderedMap.prototype.wasAltered = function wasAltered() {\n      return this._map.wasAltered() || this._list.wasAltered();\n    };\n\n    OrderedMap.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n      return this._list.__iterate(function (entry) {\n        return entry && fn(entry[1], entry[0], this$1);\n      }, reverse);\n    };\n\n    OrderedMap.prototype.__iterator = function __iterator(type, reverse) {\n      return this._list.fromEntrySeq().__iterator(type, reverse);\n    };\n\n    OrderedMap.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n\n      var newMap = this._map.__ensureOwner(ownerID);\n\n      var newList = this._list.__ensureOwner(ownerID);\n\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyOrderedMap();\n        }\n\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        this._list = newList;\n        return this;\n      }\n\n      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n    };\n\n    return OrderedMap;\n  }(Map);\n\n  OrderedMap.isOrderedMap = isOrderedMap;\n  OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;\n  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\n  function makeOrderedMap(map, list, ownerID, hash) {\n    var omap = Object.create(OrderedMap.prototype);\n    omap.size = map ? map.size : 0;\n    omap._map = map;\n    omap._list = list;\n    omap.__ownerID = ownerID;\n    omap.__hash = hash;\n    return omap;\n  }\n\n  var EMPTY_ORDERED_MAP;\n\n  function emptyOrderedMap() {\n    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n  }\n\n  function updateOrderedMap(omap, k, v) {\n    var map = omap._map;\n    var list = omap._list;\n    var i = map.get(k);\n    var has = i !== undefined;\n    var newMap;\n    var newList;\n\n    if (v === NOT_SET) {\n      // removed\n      if (!has) {\n        return omap;\n      }\n\n      if (list.size >= SIZE && list.size >= map.size * 2) {\n        newList = list.filter(function (entry, idx) {\n          return entry !== undefined && i !== idx;\n        });\n        newMap = newList.toKeyedSeq().map(function (entry) {\n          return entry[0];\n        }).flip().toMap();\n\n        if (omap.__ownerID) {\n          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n        }\n      } else {\n        newMap = map.remove(k);\n        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n      }\n    } else if (has) {\n      if (v === list.get(i)[1]) {\n        return omap;\n      }\n\n      newMap = map;\n      newList = list.set(i, [k, v]);\n    } else {\n      newMap = map.set(k, list.size);\n      newList = list.set(list.size, [k, v]);\n    }\n\n    if (omap.__ownerID) {\n      omap.size = newMap.size;\n      omap._map = newMap;\n      omap._list = newList;\n      omap.__hash = undefined;\n      return omap;\n    }\n\n    return makeOrderedMap(newMap, newList);\n  }\n\n  var IS_STACK_SYMBOL = '@@__IMMUTABLE_STACK__@@';\n\n  function isStack(maybeStack) {\n    return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);\n  }\n\n  var Stack =\n  /*@__PURE__*/\n  function (IndexedCollection$$1) {\n    function Stack(value) {\n      return value === null || value === undefined ? emptyStack() : isStack(value) ? value : emptyStack().pushAll(value);\n    }\n\n    if (IndexedCollection$$1) Stack.__proto__ = IndexedCollection$$1;\n    Stack.prototype = Object.create(IndexedCollection$$1 && IndexedCollection$$1.prototype);\n    Stack.prototype.constructor = Stack;\n\n    Stack.of = function of()\n    /*...values*/\n    {\n      return this(arguments);\n    };\n\n    Stack.prototype.toString = function toString() {\n      return this.__toString('Stack [', ']');\n    }; // @pragma Access\n\n\n    Stack.prototype.get = function get(index, notSetValue) {\n      var head = this._head;\n      index = wrapIndex(this, index);\n\n      while (head && index--) {\n        head = head.next;\n      }\n\n      return head ? head.value : notSetValue;\n    };\n\n    Stack.prototype.peek = function peek() {\n      return this._head && this._head.value;\n    }; // @pragma Modification\n\n\n    Stack.prototype.push = function push()\n    /*...values*/\n    {\n      var arguments$1 = arguments;\n\n      if (arguments.length === 0) {\n        return this;\n      }\n\n      var newSize = this.size + arguments.length;\n      var head = this._head;\n\n      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n        head = {\n          value: arguments$1[ii],\n          next: head\n        };\n      }\n\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pushAll = function pushAll(iter) {\n      iter = IndexedCollection$$1(iter);\n\n      if (iter.size === 0) {\n        return this;\n      }\n\n      if (this.size === 0 && isStack(iter)) {\n        return iter;\n      }\n\n      assertNotInfinite(iter.size);\n      var newSize = this.size;\n      var head = this._head;\n\n      iter.__iterate(function (value) {\n        newSize++;\n        head = {\n          value: value,\n          next: head\n        };\n      },\n      /* reverse */\n      true);\n\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pop = function pop() {\n      return this.slice(1);\n    };\n\n    Stack.prototype.clear = function clear() {\n      if (this.size === 0) {\n        return this;\n      }\n\n      if (this.__ownerID) {\n        this.size = 0;\n        this._head = undefined;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n\n      return emptyStack();\n    };\n\n    Stack.prototype.slice = function slice(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n\n      var resolvedBegin = resolveBegin(begin, this.size);\n      var resolvedEnd = resolveEnd(end, this.size);\n\n      if (resolvedEnd !== this.size) {\n        // super.slice(begin, end);\n        return IndexedCollection$$1.prototype.slice.call(this, begin, end);\n      }\n\n      var newSize = this.size - resolvedBegin;\n      var head = this._head;\n\n      while (resolvedBegin--) {\n        head = head.next;\n      }\n\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n\n      return makeStack(newSize, head);\n    }; // @pragma Mutability\n\n\n    Stack.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyStack();\n        }\n\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n\n      return makeStack(this.size, this._head, ownerID, this.__hash);\n    }; // @pragma Iteration\n\n\n    Stack.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return new ArraySeq(this.toArray()).__iterate(function (v, k) {\n          return fn(v, k, this$1);\n        }, reverse);\n      }\n\n      var iterations = 0;\n      var node = this._head;\n\n      while (node) {\n        if (fn(node.value, iterations++, this) === false) {\n          break;\n        }\n\n        node = node.next;\n      }\n\n      return iterations;\n    };\n\n    Stack.prototype.__iterator = function __iterator(type, reverse) {\n      if (reverse) {\n        return new ArraySeq(this.toArray()).__iterator(type, reverse);\n      }\n\n      var iterations = 0;\n      var node = this._head;\n      return new Iterator(function () {\n        if (node) {\n          var value = node.value;\n          node = node.next;\n          return iteratorValue(type, iterations++, value);\n        }\n\n        return iteratorDone();\n      });\n    };\n\n    return Stack;\n  }(IndexedCollection);\n\n  Stack.isStack = isStack;\n  var StackPrototype = Stack.prototype;\n  StackPrototype[IS_STACK_SYMBOL] = true;\n  StackPrototype.shift = StackPrototype.pop;\n  StackPrototype.unshift = StackPrototype.push;\n  StackPrototype.unshiftAll = StackPrototype.pushAll;\n  StackPrototype.withMutations = withMutations;\n  StackPrototype.wasAltered = wasAltered;\n  StackPrototype.asImmutable = asImmutable;\n  StackPrototype['@@transducer/init'] = StackPrototype.asMutable = asMutable;\n\n  StackPrototype['@@transducer/step'] = function (result, arr) {\n    return result.unshift(arr);\n  };\n\n  StackPrototype['@@transducer/result'] = function (obj) {\n    return obj.asImmutable();\n  };\n\n  function makeStack(size, head, ownerID, hash) {\n    var map = Object.create(StackPrototype);\n    map.size = size;\n    map._head = head;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_STACK;\n\n  function emptyStack() {\n    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n  }\n\n  var IS_SET_SYMBOL = '@@__IMMUTABLE_SET__@@';\n\n  function isSet(maybeSet) {\n    return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);\n  }\n\n  function isOrderedSet(maybeOrderedSet) {\n    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n  }\n\n  function deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    if (!isCollection(b) || a.size !== undefined && b.size !== undefined && a.size !== b.size || a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {\n      return false;\n    }\n\n    if (a.size === 0 && b.size === 0) {\n      return true;\n    }\n\n    var notAssociative = !isAssociative(a);\n\n    if (isOrdered(a)) {\n      var entries = a.entries();\n      return b.every(function (v, k) {\n        var entry = entries.next().value;\n        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n      }) && entries.next().done;\n    }\n\n    var flipped = false;\n\n    if (a.size === undefined) {\n      if (b.size === undefined) {\n        if (typeof a.cacheResult === 'function') {\n          a.cacheResult();\n        }\n      } else {\n        flipped = true;\n        var _ = a;\n        a = b;\n        b = _;\n      }\n    }\n\n    var allEqual = true;\n\n    var bSize = b.__iterate(function (v, k) {\n      if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n        allEqual = false;\n        return false;\n      }\n    });\n\n    return allEqual && a.size === bSize;\n  }\n  /**\n   * Contributes additional methods to a constructor\n   */\n\n\n  function mixin(ctor, methods) {\n    var keyCopier = function (key) {\n      ctor.prototype[key] = methods[key];\n    };\n\n    Object.keys(methods).forEach(keyCopier);\n    Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n    return ctor;\n  }\n\n  function toJS(value) {\n    if (!value || typeof value !== 'object') {\n      return value;\n    }\n\n    if (!isCollection(value)) {\n      if (!isDataStructure(value)) {\n        return value;\n      }\n\n      value = Seq(value);\n    }\n\n    if (isKeyed(value)) {\n      var result$1 = {};\n\n      value.__iterate(function (v, k) {\n        result$1[k] = toJS(v);\n      });\n\n      return result$1;\n    }\n\n    var result = [];\n\n    value.__iterate(function (v) {\n      result.push(toJS(v));\n    });\n\n    return result;\n  }\n\n  var Set =\n  /*@__PURE__*/\n  function (SetCollection$$1) {\n    function Set(value) {\n      return value === null || value === undefined ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function (set) {\n        var iter = SetCollection$$1(value);\n        assertNotInfinite(iter.size);\n        iter.forEach(function (v) {\n          return set.add(v);\n        });\n      });\n    }\n\n    if (SetCollection$$1) Set.__proto__ = SetCollection$$1;\n    Set.prototype = Object.create(SetCollection$$1 && SetCollection$$1.prototype);\n    Set.prototype.constructor = Set;\n\n    Set.of = function of()\n    /*...values*/\n    {\n      return this(arguments);\n    };\n\n    Set.fromKeys = function fromKeys(value) {\n      return this(KeyedCollection(value).keySeq());\n    };\n\n    Set.intersect = function intersect(sets) {\n      sets = Collection(sets).toArray();\n      return sets.length ? SetPrototype.intersect.apply(Set(sets.pop()), sets) : emptySet();\n    };\n\n    Set.union = function union(sets) {\n      sets = Collection(sets).toArray();\n      return sets.length ? SetPrototype.union.apply(Set(sets.pop()), sets) : emptySet();\n    };\n\n    Set.prototype.toString = function toString() {\n      return this.__toString('Set {', '}');\n    }; // @pragma Access\n\n\n    Set.prototype.has = function has(value) {\n      return this._map.has(value);\n    }; // @pragma Modification\n\n\n    Set.prototype.add = function add(value) {\n      return updateSet(this, this._map.set(value, value));\n    };\n\n    Set.prototype.remove = function remove(value) {\n      return updateSet(this, this._map.remove(value));\n    };\n\n    Set.prototype.clear = function clear() {\n      return updateSet(this, this._map.clear());\n    }; // @pragma Composition\n\n\n    Set.prototype.map = function map(mapper, context) {\n      var this$1 = this;\n      var removes = [];\n      var adds = [];\n      this.forEach(function (value) {\n        var mapped = mapper.call(context, value, value, this$1);\n\n        if (mapped !== value) {\n          removes.push(value);\n          adds.push(mapped);\n        }\n      });\n      return this.withMutations(function (set) {\n        removes.forEach(function (value) {\n          return set.remove(value);\n        });\n        adds.forEach(function (value) {\n          return set.add(value);\n        });\n      });\n    };\n\n    Set.prototype.union = function union() {\n      var iters = [],\n          len = arguments.length;\n\n      while (len--) iters[len] = arguments[len];\n\n      iters = iters.filter(function (x) {\n        return x.size !== 0;\n      });\n\n      if (iters.length === 0) {\n        return this;\n      }\n\n      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n        return this.constructor(iters[0]);\n      }\n\n      return this.withMutations(function (set) {\n        for (var ii = 0; ii < iters.length; ii++) {\n          SetCollection$$1(iters[ii]).forEach(function (value) {\n            return set.add(value);\n          });\n        }\n      });\n    };\n\n    Set.prototype.intersect = function intersect() {\n      var iters = [],\n          len = arguments.length;\n\n      while (len--) iters[len] = arguments[len];\n\n      if (iters.length === 0) {\n        return this;\n      }\n\n      iters = iters.map(function (iter) {\n        return SetCollection$$1(iter);\n      });\n      var toRemove = [];\n      this.forEach(function (value) {\n        if (!iters.every(function (iter) {\n          return iter.includes(value);\n        })) {\n          toRemove.push(value);\n        }\n      });\n      return this.withMutations(function (set) {\n        toRemove.forEach(function (value) {\n          set.remove(value);\n        });\n      });\n    };\n\n    Set.prototype.subtract = function subtract() {\n      var iters = [],\n          len = arguments.length;\n\n      while (len--) iters[len] = arguments[len];\n\n      if (iters.length === 0) {\n        return this;\n      }\n\n      iters = iters.map(function (iter) {\n        return SetCollection$$1(iter);\n      });\n      var toRemove = [];\n      this.forEach(function (value) {\n        if (iters.some(function (iter) {\n          return iter.includes(value);\n        })) {\n          toRemove.push(value);\n        }\n      });\n      return this.withMutations(function (set) {\n        toRemove.forEach(function (value) {\n          set.remove(value);\n        });\n      });\n    };\n\n    Set.prototype.sort = function sort(comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator));\n    };\n\n    Set.prototype.sortBy = function sortBy(mapper, comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator, mapper));\n    };\n\n    Set.prototype.wasAltered = function wasAltered() {\n      return this._map.wasAltered();\n    };\n\n    Set.prototype.__iterate = function __iterate(fn, reverse) {\n      var this$1 = this;\n      return this._map.__iterate(function (k) {\n        return fn(k, k, this$1);\n      }, reverse);\n    };\n\n    Set.prototype.__iterator = function __iterator(type, reverse) {\n      return this._map.__iterator(type, reverse);\n    };\n\n    Set.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n\n      var newMap = this._map.__ensureOwner(ownerID);\n\n      if (!ownerID) {\n        if (this.size === 0) {\n          return this.__empty();\n        }\n\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n\n      return this.__make(newMap, ownerID);\n    };\n\n    return Set;\n  }(SetCollection);\n\n  Set.isSet = isSet;\n  var SetPrototype = Set.prototype;\n  SetPrototype[IS_SET_SYMBOL] = true;\n  SetPrototype[DELETE] = SetPrototype.remove;\n  SetPrototype.merge = SetPrototype.concat = SetPrototype.union;\n  SetPrototype.withMutations = withMutations;\n  SetPrototype.asImmutable = asImmutable;\n  SetPrototype['@@transducer/init'] = SetPrototype.asMutable = asMutable;\n\n  SetPrototype['@@transducer/step'] = function (result, arr) {\n    return result.add(arr);\n  };\n\n  SetPrototype['@@transducer/result'] = function (obj) {\n    return obj.asImmutable();\n  };\n\n  SetPrototype.__empty = emptySet;\n  SetPrototype.__make = makeSet;\n\n  function updateSet(set, newMap) {\n    if (set.__ownerID) {\n      set.size = newMap.size;\n      set._map = newMap;\n      return set;\n    }\n\n    return newMap === set._map ? set : newMap.size === 0 ? set.__empty() : set.__make(newMap);\n  }\n\n  function makeSet(map, ownerID) {\n    var set = Object.create(SetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_SET;\n\n  function emptySet() {\n    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n  }\n  /**\n   * Returns a lazy seq of nums from start (inclusive) to end\n   * (exclusive), by step, where start defaults to 0, step to 1, and end to\n   * infinity. When start is equal to end, returns empty list.\n   */\n\n\n  var Range =\n  /*@__PURE__*/\n  function (IndexedSeq$$1) {\n    function Range(start, end, step) {\n      if (!(this instanceof Range)) {\n        return new Range(start, end, step);\n      }\n\n      invariant(step !== 0, 'Cannot step a Range by 0');\n      start = start || 0;\n\n      if (end === undefined) {\n        end = Infinity;\n      }\n\n      step = step === undefined ? 1 : Math.abs(step);\n\n      if (end < start) {\n        step = -step;\n      }\n\n      this._start = start;\n      this._end = end;\n      this._step = step;\n      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n\n      if (this.size === 0) {\n        if (EMPTY_RANGE) {\n          return EMPTY_RANGE;\n        }\n\n        EMPTY_RANGE = this;\n      }\n    }\n\n    if (IndexedSeq$$1) Range.__proto__ = IndexedSeq$$1;\n    Range.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);\n    Range.prototype.constructor = Range;\n\n    Range.prototype.toString = function toString() {\n      if (this.size === 0) {\n        return 'Range []';\n      }\n\n      return 'Range [ ' + this._start + '...' + this._end + (this._step !== 1 ? ' by ' + this._step : '') + ' ]';\n    };\n\n    Range.prototype.get = function get(index, notSetValue) {\n      return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;\n    };\n\n    Range.prototype.includes = function includes(searchValue) {\n      var possibleIndex = (searchValue - this._start) / this._step;\n      return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);\n    };\n\n    Range.prototype.slice = function slice(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n\n      begin = resolveBegin(begin, this.size);\n      end = resolveEnd(end, this.size);\n\n      if (end <= begin) {\n        return new Range(0, 0);\n      }\n\n      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n    };\n\n    Range.prototype.indexOf = function indexOf(searchValue) {\n      var offsetValue = searchValue - this._start;\n\n      if (offsetValue % this._step === 0) {\n        var index = offsetValue / this._step;\n\n        if (index >= 0 && index < this.size) {\n          return index;\n        }\n      }\n\n      return -1;\n    };\n\n    Range.prototype.lastIndexOf = function lastIndexOf(searchValue) {\n      return this.indexOf(searchValue);\n    };\n\n    Range.prototype.__iterate = function __iterate(fn, reverse) {\n      var size = this.size;\n      var step = this._step;\n      var value = reverse ? this._start + (size - 1) * step : this._start;\n      var i = 0;\n\n      while (i !== size) {\n        if (fn(value, reverse ? size - ++i : i++, this) === false) {\n          break;\n        }\n\n        value += reverse ? -step : step;\n      }\n\n      return i;\n    };\n\n    Range.prototype.__iterator = function __iterator(type, reverse) {\n      var size = this.size;\n      var step = this._step;\n      var value = reverse ? this._start + (size - 1) * step : this._start;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n\n        var v = value;\n        value += reverse ? -step : step;\n        return iteratorValue(type, reverse ? size - ++i : i++, v);\n      });\n    };\n\n    Range.prototype.equals = function equals(other) {\n      return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);\n    };\n\n    return Range;\n  }(IndexedSeq);\n\n  var EMPTY_RANGE;\n\n  function getIn(collection, searchKeyPath, notSetValue) {\n    var keyPath = coerceKeyPath(searchKeyPath);\n    var i = 0;\n\n    while (i !== keyPath.length) {\n      collection = get(collection, keyPath[i++], NOT_SET);\n\n      if (collection === NOT_SET) {\n        return notSetValue;\n      }\n    }\n\n    return collection;\n  }\n\n  function getIn$1(searchKeyPath, notSetValue) {\n    return getIn(this, searchKeyPath, notSetValue);\n  }\n\n  function hasIn(collection, keyPath) {\n    return getIn(collection, keyPath, NOT_SET) !== NOT_SET;\n  }\n\n  function hasIn$1(searchKeyPath) {\n    return hasIn(this, searchKeyPath);\n  }\n\n  function toObject() {\n    assertNotInfinite(this.size);\n    var object = {};\n\n    this.__iterate(function (v, k) {\n      object[k] = v;\n    });\n\n    return object;\n  } // Note: all of these methods are deprecated.\n\n\n  Collection.isIterable = isCollection;\n  Collection.isKeyed = isKeyed;\n  Collection.isIndexed = isIndexed;\n  Collection.isAssociative = isAssociative;\n  Collection.isOrdered = isOrdered;\n  Collection.Iterator = Iterator;\n  mixin(Collection, {\n    // ### Conversion to other types\n    toArray: function toArray() {\n      assertNotInfinite(this.size);\n      var array = new Array(this.size || 0);\n      var useTuples = isKeyed(this);\n      var i = 0;\n\n      this.__iterate(function (v, k) {\n        // Keyed collections produce an array of tuples.\n        array[i++] = useTuples ? [k, v] : v;\n      });\n\n      return array;\n    },\n    toIndexedSeq: function toIndexedSeq() {\n      return new ToIndexedSequence(this);\n    },\n    toJS: function toJS$1() {\n      return toJS(this);\n    },\n    toKeyedSeq: function toKeyedSeq() {\n      return new ToKeyedSequence(this, true);\n    },\n    toMap: function toMap() {\n      // Use Late Binding here to solve the circular dependency.\n      return Map(this.toKeyedSeq());\n    },\n    toObject: toObject,\n    toOrderedMap: function toOrderedMap() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedMap(this.toKeyedSeq());\n    },\n    toOrderedSet: function toOrderedSet() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n    },\n    toSet: function toSet() {\n      // Use Late Binding here to solve the circular dependency.\n      return Set(isKeyed(this) ? this.valueSeq() : this);\n    },\n    toSetSeq: function toSetSeq() {\n      return new ToSetSequence(this);\n    },\n    toSeq: function toSeq() {\n      return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();\n    },\n    toStack: function toStack() {\n      // Use Late Binding here to solve the circular dependency.\n      return Stack(isKeyed(this) ? this.valueSeq() : this);\n    },\n    toList: function toList() {\n      // Use Late Binding here to solve the circular dependency.\n      return List(isKeyed(this) ? this.valueSeq() : this);\n    },\n    // ### Common JavaScript methods and properties\n    toString: function toString() {\n      return '[Collection]';\n    },\n    __toString: function __toString(head, tail) {\n      if (this.size === 0) {\n        return head + tail;\n      }\n\n      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n    },\n    // ### ES6 Collection methods (ES6 Array and Map)\n    concat: function concat() {\n      var values = [],\n          len = arguments.length;\n\n      while (len--) values[len] = arguments[len];\n\n      return reify(this, concatFactory(this, values));\n    },\n    includes: function includes(searchValue) {\n      return this.some(function (value) {\n        return is(value, searchValue);\n      });\n    },\n    entries: function entries() {\n      return this.__iterator(ITERATE_ENTRIES);\n    },\n    every: function every(predicate, context) {\n      assertNotInfinite(this.size);\n      var returnValue = true;\n\n      this.__iterate(function (v, k, c) {\n        if (!predicate.call(context, v, k, c)) {\n          returnValue = false;\n          return false;\n        }\n      });\n\n      return returnValue;\n    },\n    filter: function filter(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, true));\n    },\n    find: function find(predicate, context, notSetValue) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[1] : notSetValue;\n    },\n    forEach: function forEach(sideEffect, context) {\n      assertNotInfinite(this.size);\n      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n    },\n    join: function join(separator) {\n      assertNotInfinite(this.size);\n      separator = separator !== undefined ? '' + separator : ',';\n      var joined = '';\n      var isFirst = true;\n\n      this.__iterate(function (v) {\n        isFirst ? isFirst = false : joined += separator;\n        joined += v !== null && v !== undefined ? v.toString() : '';\n      });\n\n      return joined;\n    },\n    keys: function keys() {\n      return this.__iterator(ITERATE_KEYS);\n    },\n    map: function map(mapper, context) {\n      return reify(this, mapFactory(this, mapper, context));\n    },\n    reduce: function reduce$1(reducer, initialReduction, context) {\n      return reduce(this, reducer, initialReduction, context, arguments.length < 2, false);\n    },\n    reduceRight: function reduceRight(reducer, initialReduction, context) {\n      return reduce(this, reducer, initialReduction, context, arguments.length < 2, true);\n    },\n    reverse: function reverse() {\n      return reify(this, reverseFactory(this, true));\n    },\n    slice: function slice(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, true));\n    },\n    some: function some(predicate, context) {\n      return !this.every(not(predicate), context);\n    },\n    sort: function sort(comparator) {\n      return reify(this, sortFactory(this, comparator));\n    },\n    values: function values() {\n      return this.__iterator(ITERATE_VALUES);\n    },\n    // ### More sequential methods\n    butLast: function butLast() {\n      return this.slice(0, -1);\n    },\n    isEmpty: function isEmpty() {\n      return this.size !== undefined ? this.size === 0 : !this.some(function () {\n        return true;\n      });\n    },\n    count: function count(predicate, context) {\n      return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);\n    },\n    countBy: function countBy(grouper, context) {\n      return countByFactory(this, grouper, context);\n    },\n    equals: function equals(other) {\n      return deepEqual(this, other);\n    },\n    entrySeq: function entrySeq() {\n      var collection = this;\n\n      if (collection._cache) {\n        // We cache as an entries array, so we can just return the cache!\n        return new ArraySeq(collection._cache);\n      }\n\n      var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();\n\n      entriesSequence.fromEntrySeq = function () {\n        return collection.toSeq();\n      };\n\n      return entriesSequence;\n    },\n    filterNot: function filterNot(predicate, context) {\n      return this.filter(not(predicate), context);\n    },\n    findEntry: function findEntry(predicate, context, notSetValue) {\n      var found = notSetValue;\n\n      this.__iterate(function (v, k, c) {\n        if (predicate.call(context, v, k, c)) {\n          found = [k, v];\n          return false;\n        }\n      });\n\n      return found;\n    },\n    findKey: function findKey(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry && entry[0];\n    },\n    findLast: function findLast(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n    },\n    findLastEntry: function findLastEntry(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);\n    },\n    findLastKey: function findLastKey(predicate, context) {\n      return this.toKeyedSeq().reverse().findKey(predicate, context);\n    },\n    first: function first(notSetValue) {\n      return this.find(returnTrue, null, notSetValue);\n    },\n    flatMap: function flatMap(mapper, context) {\n      return reify(this, flatMapFactory(this, mapper, context));\n    },\n    flatten: function flatten(depth) {\n      return reify(this, flattenFactory(this, depth, true));\n    },\n    fromEntrySeq: function fromEntrySeq() {\n      return new FromEntriesSequence(this);\n    },\n    get: function get(searchKey, notSetValue) {\n      return this.find(function (_, key) {\n        return is(key, searchKey);\n      }, undefined, notSetValue);\n    },\n    getIn: getIn$1,\n    groupBy: function groupBy(grouper, context) {\n      return groupByFactory(this, grouper, context);\n    },\n    has: function has(searchKey) {\n      return this.get(searchKey, NOT_SET) !== NOT_SET;\n    },\n    hasIn: hasIn$1,\n    isSubset: function isSubset(iter) {\n      iter = typeof iter.includes === 'function' ? iter : Collection(iter);\n      return this.every(function (value) {\n        return iter.includes(value);\n      });\n    },\n    isSuperset: function isSuperset(iter) {\n      iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);\n      return iter.isSubset(this);\n    },\n    keyOf: function keyOf(searchValue) {\n      return this.findKey(function (value) {\n        return is(value, searchValue);\n      });\n    },\n    keySeq: function keySeq() {\n      return this.toSeq().map(keyMapper).toIndexedSeq();\n    },\n    last: function last(notSetValue) {\n      return this.toSeq().reverse().first(notSetValue);\n    },\n    lastKeyOf: function lastKeyOf(searchValue) {\n      return this.toKeyedSeq().reverse().keyOf(searchValue);\n    },\n    max: function max(comparator) {\n      return maxFactory(this, comparator);\n    },\n    maxBy: function maxBy(mapper, comparator) {\n      return maxFactory(this, comparator, mapper);\n    },\n    min: function min(comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n    },\n    minBy: function minBy(mapper, comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n    },\n    rest: function rest() {\n      return this.slice(1);\n    },\n    skip: function skip(amount) {\n      return amount === 0 ? this : this.slice(Math.max(0, amount));\n    },\n    skipLast: function skipLast(amount) {\n      return amount === 0 ? this : this.slice(0, -Math.max(0, amount));\n    },\n    skipWhile: function skipWhile(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, true));\n    },\n    skipUntil: function skipUntil(predicate, context) {\n      return this.skipWhile(not(predicate), context);\n    },\n    sortBy: function sortBy(mapper, comparator) {\n      return reify(this, sortFactory(this, comparator, mapper));\n    },\n    take: function take(amount) {\n      return this.slice(0, Math.max(0, amount));\n    },\n    takeLast: function takeLast(amount) {\n      return this.slice(-Math.max(0, amount));\n    },\n    takeWhile: function takeWhile(predicate, context) {\n      return reify(this, takeWhileFactory(this, predicate, context));\n    },\n    takeUntil: function takeUntil(predicate, context) {\n      return this.takeWhile(not(predicate), context);\n    },\n    update: function update(fn) {\n      return fn(this);\n    },\n    valueSeq: function valueSeq() {\n      return this.toIndexedSeq();\n    },\n    // ### Hashable Object\n    hashCode: function hashCode() {\n      return this.__hash || (this.__hash = hashCollection(this));\n    } // ### Internal\n    // abstract __iterate(fn, reverse)\n    // abstract __iterator(type, reverse)\n\n  });\n  var CollectionPrototype = Collection.prototype;\n  CollectionPrototype[IS_COLLECTION_SYMBOL] = true;\n  CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;\n  CollectionPrototype.toJSON = CollectionPrototype.toArray;\n  CollectionPrototype.__toStringMapper = quoteString;\n\n  CollectionPrototype.inspect = CollectionPrototype.toSource = function () {\n    return this.toString();\n  };\n\n  CollectionPrototype.chain = CollectionPrototype.flatMap;\n  CollectionPrototype.contains = CollectionPrototype.includes;\n  mixin(KeyedCollection, {\n    // ### More sequential methods\n    flip: function flip() {\n      return reify(this, flipFactory(this));\n    },\n    mapEntries: function mapEntries(mapper, context) {\n      var this$1 = this;\n      var iterations = 0;\n      return reify(this, this.toSeq().map(function (v, k) {\n        return mapper.call(context, [k, v], iterations++, this$1);\n      }).fromEntrySeq());\n    },\n    mapKeys: function mapKeys(mapper, context) {\n      var this$1 = this;\n      return reify(this, this.toSeq().flip().map(function (k, v) {\n        return mapper.call(context, k, v, this$1);\n      }).flip());\n    }\n  });\n  var KeyedCollectionPrototype = KeyedCollection.prototype;\n  KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;\n  KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;\n  KeyedCollectionPrototype.toJSON = toObject;\n\n  KeyedCollectionPrototype.__toStringMapper = function (v, k) {\n    return quoteString(k) + ': ' + quoteString(v);\n  };\n\n  mixin(IndexedCollection, {\n    // ### Conversion to other types\n    toKeyedSeq: function toKeyedSeq() {\n      return new ToKeyedSequence(this, false);\n    },\n    // ### ES6 Collection methods (ES6 Array and Map)\n    filter: function filter(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, false));\n    },\n    findIndex: function findIndex(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n    indexOf: function indexOf(searchValue) {\n      var key = this.keyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n    lastIndexOf: function lastIndexOf(searchValue) {\n      var key = this.lastKeyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n    reverse: function reverse() {\n      return reify(this, reverseFactory(this, false));\n    },\n    slice: function slice(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, false));\n    },\n    splice: function splice(index, removeNum\n    /*, ...values*/\n    ) {\n      var numArgs = arguments.length;\n      removeNum = Math.max(removeNum || 0, 0);\n\n      if (numArgs === 0 || numArgs === 2 && !removeNum) {\n        return this;\n      } // If index is negative, it should resolve relative to the size of the\n      // collection. However size may be expensive to compute if not cached, so\n      // only call count() if the number is in fact negative.\n\n\n      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n      var spliced = this.slice(0, index);\n      return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));\n    },\n    // ### More collection methods\n    findLastIndex: function findLastIndex(predicate, context) {\n      var entry = this.findLastEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n    first: function first(notSetValue) {\n      return this.get(0, notSetValue);\n    },\n    flatten: function flatten(depth) {\n      return reify(this, flattenFactory(this, depth, false));\n    },\n    get: function get(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return index < 0 || this.size === Infinity || this.size !== undefined && index > this.size ? notSetValue : this.find(function (_, key) {\n        return key === index;\n      }, undefined, notSetValue);\n    },\n    has: function has(index) {\n      index = wrapIndex(this, index);\n      return index >= 0 && (this.size !== undefined ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);\n    },\n    interpose: function interpose(separator) {\n      return reify(this, interposeFactory(this, separator));\n    },\n    interleave: function interleave()\n    /*...collections*/\n    {\n      var collections = [this].concat(arrCopy(arguments));\n      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);\n      var interleaved = zipped.flatten(true);\n\n      if (zipped.size) {\n        interleaved.size = zipped.size * collections.length;\n      }\n\n      return reify(this, interleaved);\n    },\n    keySeq: function keySeq() {\n      return Range(0, this.size);\n    },\n    last: function last(notSetValue) {\n      return this.get(-1, notSetValue);\n    },\n    skipWhile: function skipWhile(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, false));\n    },\n    zip: function zip()\n    /*, ...collections */\n    {\n      var collections = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, collections));\n    },\n    zipAll: function zipAll()\n    /*, ...collections */\n    {\n      var collections = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, collections, true));\n    },\n    zipWith: function zipWith(zipper\n    /*, ...collections */\n    ) {\n      var collections = arrCopy(arguments);\n      collections[0] = this;\n      return reify(this, zipWithFactory(this, zipper, collections));\n    }\n  });\n  var IndexedCollectionPrototype = IndexedCollection.prototype;\n  IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;\n  IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;\n  mixin(SetCollection, {\n    // ### ES6 Collection methods (ES6 Array and Map)\n    get: function get(value, notSetValue) {\n      return this.has(value) ? value : notSetValue;\n    },\n    includes: function includes(value) {\n      return this.has(value);\n    },\n    // ### More sequential methods\n    keySeq: function keySeq() {\n      return this.valueSeq();\n    }\n  });\n  SetCollection.prototype.has = CollectionPrototype.includes;\n  SetCollection.prototype.contains = SetCollection.prototype.includes; // Mixin subclasses\n\n  mixin(KeyedSeq, KeyedCollection.prototype);\n  mixin(IndexedSeq, IndexedCollection.prototype);\n  mixin(SetSeq, SetCollection.prototype); // #pragma Helper functions\n\n  function reduce(collection, reducer, reduction, context, useFirst, reverse) {\n    assertNotInfinite(collection.size);\n\n    collection.__iterate(function (v, k, c) {\n      if (useFirst) {\n        useFirst = false;\n        reduction = v;\n      } else {\n        reduction = reducer.call(context, reduction, v, k, c);\n      }\n    }, reverse);\n\n    return reduction;\n  }\n\n  function keyMapper(v, k) {\n    return k;\n  }\n\n  function entryMapper(v, k) {\n    return [k, v];\n  }\n\n  function not(predicate) {\n    return function () {\n      return !predicate.apply(this, arguments);\n    };\n  }\n\n  function neg(predicate) {\n    return function () {\n      return -predicate.apply(this, arguments);\n    };\n  }\n\n  function defaultZipper() {\n    return arrCopy(arguments);\n  }\n\n  function defaultNegComparator(a, b) {\n    return a < b ? 1 : a > b ? -1 : 0;\n  }\n\n  function hashCollection(collection) {\n    if (collection.size === Infinity) {\n      return 0;\n    }\n\n    var ordered = isOrdered(collection);\n    var keyed = isKeyed(collection);\n    var h = ordered ? 1 : 0;\n\n    var size = collection.__iterate(keyed ? ordered ? function (v, k) {\n      h = 31 * h + hashMerge(hash(v), hash(k)) | 0;\n    } : function (v, k) {\n      h = h + hashMerge(hash(v), hash(k)) | 0;\n    } : ordered ? function (v) {\n      h = 31 * h + hash(v) | 0;\n    } : function (v) {\n      h = h + hash(v) | 0;\n    });\n\n    return murmurHashOfSize(size, h);\n  }\n\n  function murmurHashOfSize(size, h) {\n    h = imul(h, 0xcc9e2d51);\n    h = imul(h << 15 | h >>> -15, 0x1b873593);\n    h = imul(h << 13 | h >>> -13, 5);\n    h = (h + 0xe6546b64 | 0) ^ size;\n    h = imul(h ^ h >>> 16, 0x85ebca6b);\n    h = imul(h ^ h >>> 13, 0xc2b2ae35);\n    h = smi(h ^ h >>> 16);\n    return h;\n  }\n\n  function hashMerge(a, b) {\n    return a ^ b + 0x9e3779b9 + (a << 6) + (a >> 2) | 0; // int\n  }\n\n  var OrderedSet =\n  /*@__PURE__*/\n  function (Set$$1) {\n    function OrderedSet(value) {\n      return value === null || value === undefined ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function (set) {\n        var iter = SetCollection(value);\n        assertNotInfinite(iter.size);\n        iter.forEach(function (v) {\n          return set.add(v);\n        });\n      });\n    }\n\n    if (Set$$1) OrderedSet.__proto__ = Set$$1;\n    OrderedSet.prototype = Object.create(Set$$1 && Set$$1.prototype);\n    OrderedSet.prototype.constructor = OrderedSet;\n\n    OrderedSet.of = function of()\n    /*...values*/\n    {\n      return this(arguments);\n    };\n\n    OrderedSet.fromKeys = function fromKeys(value) {\n      return this(KeyedCollection(value).keySeq());\n    };\n\n    OrderedSet.prototype.toString = function toString() {\n      return this.__toString('OrderedSet {', '}');\n    };\n\n    return OrderedSet;\n  }(Set);\n\n  OrderedSet.isOrderedSet = isOrderedSet;\n  var OrderedSetPrototype = OrderedSet.prototype;\n  OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;\n  OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;\n  OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;\n  OrderedSetPrototype.__empty = emptyOrderedSet;\n  OrderedSetPrototype.__make = makeOrderedSet;\n\n  function makeOrderedSet(map, ownerID) {\n    var set = Object.create(OrderedSetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_ORDERED_SET;\n\n  function emptyOrderedSet() {\n    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n  }\n\n  var Record = function Record(defaultValues, name) {\n    var hasInitialized;\n\n    var RecordType = function Record(values) {\n      var this$1 = this;\n\n      if (values instanceof RecordType) {\n        return values;\n      }\n\n      if (!(this instanceof RecordType)) {\n        return new RecordType(values);\n      }\n\n      if (!hasInitialized) {\n        hasInitialized = true;\n        var keys = Object.keys(defaultValues);\n        var indices = RecordTypePrototype._indices = {}; // Deprecated: left to attempt not to break any external code which\n        // relies on a ._name property existing on record instances.\n        // Use Record.getDescriptiveName() instead\n\n        RecordTypePrototype._name = name;\n        RecordTypePrototype._keys = keys;\n        RecordTypePrototype._defaultValues = defaultValues;\n\n        for (var i = 0; i < keys.length; i++) {\n          var propName = keys[i];\n          indices[propName] = i;\n\n          if (RecordTypePrototype[propName]) {\n            /* eslint-disable no-console */\n            typeof console === 'object' && console.warn && console.warn('Cannot define ' + recordName(this) + ' with property \"' + propName + '\" since that property name is part of the Record API.');\n            /* eslint-enable no-console */\n          } else {\n            setProp(RecordTypePrototype, propName);\n          }\n        }\n      }\n\n      this.__ownerID = undefined;\n      this._values = List().withMutations(function (l) {\n        l.setSize(this$1._keys.length);\n        KeyedCollection(values).forEach(function (v, k) {\n          l.set(this$1._indices[k], v === this$1._defaultValues[k] ? undefined : v);\n        });\n      });\n    };\n\n    var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n    RecordTypePrototype.constructor = RecordType;\n\n    if (name) {\n      RecordType.displayName = name;\n    }\n\n    return RecordType;\n  };\n\n  Record.prototype.toString = function toString() {\n    var str = recordName(this) + ' { ';\n    var keys = this._keys;\n    var k;\n\n    for (var i = 0, l = keys.length; i !== l; i++) {\n      k = keys[i];\n      str += (i ? ', ' : '') + k + ': ' + quoteString(this.get(k));\n    }\n\n    return str + ' }';\n  };\n\n  Record.prototype.equals = function equals(other) {\n    return this === other || other && this._keys === other._keys && recordSeq(this).equals(recordSeq(other));\n  };\n\n  Record.prototype.hashCode = function hashCode() {\n    return recordSeq(this).hashCode();\n  }; // @pragma Access\n\n\n  Record.prototype.has = function has(k) {\n    return this._indices.hasOwnProperty(k);\n  };\n\n  Record.prototype.get = function get(k, notSetValue) {\n    if (!this.has(k)) {\n      return notSetValue;\n    }\n\n    var index = this._indices[k];\n\n    var value = this._values.get(index);\n\n    return value === undefined ? this._defaultValues[k] : value;\n  }; // @pragma Modification\n\n\n  Record.prototype.set = function set(k, v) {\n    if (this.has(k)) {\n      var newValues = this._values.set(this._indices[k], v === this._defaultValues[k] ? undefined : v);\n\n      if (newValues !== this._values && !this.__ownerID) {\n        return makeRecord(this, newValues);\n      }\n    }\n\n    return this;\n  };\n\n  Record.prototype.remove = function remove(k) {\n    return this.set(k);\n  };\n\n  Record.prototype.clear = function clear() {\n    var newValues = this._values.clear().setSize(this._keys.length);\n\n    return this.__ownerID ? this : makeRecord(this, newValues);\n  };\n\n  Record.prototype.wasAltered = function wasAltered() {\n    return this._values.wasAltered();\n  };\n\n  Record.prototype.toSeq = function toSeq() {\n    return recordSeq(this);\n  };\n\n  Record.prototype.toJS = function toJS$1() {\n    return toJS(this);\n  };\n\n  Record.prototype.entries = function entries() {\n    return this.__iterator(ITERATE_ENTRIES);\n  };\n\n  Record.prototype.__iterator = function __iterator(type, reverse) {\n    return recordSeq(this).__iterator(type, reverse);\n  };\n\n  Record.prototype.__iterate = function __iterate(fn, reverse) {\n    return recordSeq(this).__iterate(fn, reverse);\n  };\n\n  Record.prototype.__ensureOwner = function __ensureOwner(ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n\n    var newValues = this._values.__ensureOwner(ownerID);\n\n    if (!ownerID) {\n      this.__ownerID = ownerID;\n      this._values = newValues;\n      return this;\n    }\n\n    return makeRecord(this, newValues, ownerID);\n  };\n\n  Record.isRecord = isRecord;\n  Record.getDescriptiveName = recordName;\n  var RecordPrototype = Record.prototype;\n  RecordPrototype[IS_RECORD_SYMBOL] = true;\n  RecordPrototype[DELETE] = RecordPrototype.remove;\n  RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;\n  RecordPrototype.getIn = getIn$1;\n  RecordPrototype.hasIn = CollectionPrototype.hasIn;\n  RecordPrototype.merge = merge;\n  RecordPrototype.mergeWith = mergeWith;\n  RecordPrototype.mergeIn = mergeIn;\n  RecordPrototype.mergeDeep = mergeDeep$1;\n  RecordPrototype.mergeDeepWith = mergeDeepWith$1;\n  RecordPrototype.mergeDeepIn = mergeDeepIn;\n  RecordPrototype.setIn = setIn$1;\n  RecordPrototype.update = update$1;\n  RecordPrototype.updateIn = updateIn$1;\n  RecordPrototype.withMutations = withMutations;\n  RecordPrototype.asMutable = asMutable;\n  RecordPrototype.asImmutable = asImmutable;\n  RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;\n  RecordPrototype.toJSON = RecordPrototype.toObject = CollectionPrototype.toObject;\n\n  RecordPrototype.inspect = RecordPrototype.toSource = function () {\n    return this.toString();\n  };\n\n  function makeRecord(likeRecord, values, ownerID) {\n    var record = Object.create(Object.getPrototypeOf(likeRecord));\n    record._values = values;\n    record.__ownerID = ownerID;\n    return record;\n  }\n\n  function recordName(record) {\n    return record.constructor.displayName || record.constructor.name || 'Record';\n  }\n\n  function recordSeq(record) {\n    return keyedSeqFromValue(record._keys.map(function (k) {\n      return [k, record.get(k)];\n    }));\n  }\n\n  function setProp(prototype, name) {\n    try {\n      Object.defineProperty(prototype, name, {\n        get: function () {\n          return this.get(name);\n        },\n        set: function (value) {\n          invariant(this.__ownerID, 'Cannot set on an immutable record.');\n          this.set(name, value);\n        }\n      });\n    } catch (error) {// Object.defineProperty failed. Probably IE8.\n    }\n  }\n  /**\n   * Returns a lazy Seq of `value` repeated `times` times. When `times` is\n   * undefined, returns an infinite sequence of `value`.\n   */\n\n\n  var Repeat =\n  /*@__PURE__*/\n  function (IndexedSeq$$1) {\n    function Repeat(value, times) {\n      if (!(this instanceof Repeat)) {\n        return new Repeat(value, times);\n      }\n\n      this._value = value;\n      this.size = times === undefined ? Infinity : Math.max(0, times);\n\n      if (this.size === 0) {\n        if (EMPTY_REPEAT) {\n          return EMPTY_REPEAT;\n        }\n\n        EMPTY_REPEAT = this;\n      }\n    }\n\n    if (IndexedSeq$$1) Repeat.__proto__ = IndexedSeq$$1;\n    Repeat.prototype = Object.create(IndexedSeq$$1 && IndexedSeq$$1.prototype);\n    Repeat.prototype.constructor = Repeat;\n\n    Repeat.prototype.toString = function toString() {\n      if (this.size === 0) {\n        return 'Repeat []';\n      }\n\n      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n    };\n\n    Repeat.prototype.get = function get(index, notSetValue) {\n      return this.has(index) ? this._value : notSetValue;\n    };\n\n    Repeat.prototype.includes = function includes(searchValue) {\n      return is(this._value, searchValue);\n    };\n\n    Repeat.prototype.slice = function slice(begin, end) {\n      var size = this.size;\n      return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n    };\n\n    Repeat.prototype.reverse = function reverse() {\n      return this;\n    };\n\n    Repeat.prototype.indexOf = function indexOf(searchValue) {\n      if (is(this._value, searchValue)) {\n        return 0;\n      }\n\n      return -1;\n    };\n\n    Repeat.prototype.lastIndexOf = function lastIndexOf(searchValue) {\n      if (is(this._value, searchValue)) {\n        return this.size;\n      }\n\n      return -1;\n    };\n\n    Repeat.prototype.__iterate = function __iterate(fn, reverse) {\n      var size = this.size;\n      var i = 0;\n\n      while (i !== size) {\n        if (fn(this._value, reverse ? size - ++i : i++, this) === false) {\n          break;\n        }\n      }\n\n      return i;\n    };\n\n    Repeat.prototype.__iterator = function __iterator(type, reverse) {\n      var this$1 = this;\n      var size = this.size;\n      var i = 0;\n      return new Iterator(function () {\n        return i === size ? iteratorDone() : iteratorValue(type, reverse ? size - ++i : i++, this$1._value);\n      });\n    };\n\n    Repeat.prototype.equals = function equals(other) {\n      return other instanceof Repeat ? is(this._value, other._value) : deepEqual(other);\n    };\n\n    return Repeat;\n  }(IndexedSeq);\n\n  var EMPTY_REPEAT;\n\n  function fromJS(value, converter) {\n    return fromJSWith([], converter || defaultConverter, value, '', converter && converter.length > 2 ? [] : undefined, {\n      '': value\n    });\n  }\n\n  function fromJSWith(stack, converter, value, key, keyPath, parentValue) {\n    var toSeq = Array.isArray(value) ? IndexedSeq : isPlainObj(value) ? KeyedSeq : null;\n\n    if (toSeq) {\n      if (~stack.indexOf(value)) {\n        throw new TypeError('Cannot convert circular structure to Immutable');\n      }\n\n      stack.push(value);\n      keyPath && key !== '' && keyPath.push(key);\n      var converted = converter.call(parentValue, key, toSeq(value).map(function (v, k) {\n        return fromJSWith(stack, converter, v, k, keyPath, value);\n      }), keyPath && keyPath.slice());\n      stack.pop();\n      keyPath && keyPath.pop();\n      return converted;\n    }\n\n    return value;\n  }\n\n  function defaultConverter(k, v) {\n    return isKeyed(v) ? v.toMap() : v.toList();\n  }\n\n  var version = \"4.0.0-rc.11\";\n  var Immutable = {\n    version: version,\n    Collection: Collection,\n    // Note: Iterable is deprecated\n    Iterable: Collection,\n    Seq: Seq,\n    Map: Map,\n    OrderedMap: OrderedMap,\n    List: List,\n    Stack: Stack,\n    Set: Set,\n    OrderedSet: OrderedSet,\n    Record: Record,\n    Range: Range,\n    Repeat: Repeat,\n    is: is,\n    fromJS: fromJS,\n    hash: hash,\n    isImmutable: isImmutable,\n    isCollection: isCollection,\n    isKeyed: isKeyed,\n    isIndexed: isIndexed,\n    isAssociative: isAssociative,\n    isOrdered: isOrdered,\n    isValueObject: isValueObject,\n    isSeq: isSeq,\n    isList: isList,\n    isMap: isMap,\n    isOrderedMap: isOrderedMap,\n    isStack: isStack,\n    isSet: isSet,\n    isOrderedSet: isOrderedSet,\n    isRecord: isRecord,\n    get: get,\n    getIn: getIn,\n    has: has,\n    hasIn: hasIn,\n    merge: merge$1,\n    mergeDeep: mergeDeep,\n    mergeWith: mergeWith$1,\n    mergeDeepWith: mergeDeepWith,\n    remove: remove,\n    removeIn: removeIn,\n    set: set,\n    setIn: setIn,\n    update: update,\n    updateIn: updateIn\n  }; // Note: Iterable is deprecated\n\n  var Iterable = Collection;\n  exports.default = Immutable;\n  exports.version = version;\n  exports.Collection = Collection;\n  exports.Iterable = Iterable;\n  exports.Seq = Seq;\n  exports.Map = Map;\n  exports.OrderedMap = OrderedMap;\n  exports.List = List;\n  exports.Stack = Stack;\n  exports.Set = Set;\n  exports.OrderedSet = OrderedSet;\n  exports.Record = Record;\n  exports.Range = Range;\n  exports.Repeat = Repeat;\n  exports.is = is;\n  exports.fromJS = fromJS;\n  exports.hash = hash;\n  exports.isImmutable = isImmutable;\n  exports.isCollection = isCollection;\n  exports.isKeyed = isKeyed;\n  exports.isIndexed = isIndexed;\n  exports.isAssociative = isAssociative;\n  exports.isOrdered = isOrdered;\n  exports.isValueObject = isValueObject;\n  exports.get = get;\n  exports.getIn = getIn;\n  exports.has = has;\n  exports.hasIn = hasIn;\n  exports.merge = merge$1;\n  exports.mergeDeep = mergeDeep;\n  exports.mergeWith = mergeWith$1;\n  exports.mergeDeepWith = mergeDeepWith;\n  exports.remove = remove;\n  exports.removeIn = removeIn;\n  exports.set = set;\n  exports.setIn = setIn;\n  exports.update = update;\n  exports.updateIn = updateIn;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["/Users/MIAlien/Desktop/BW 3/front-end/water-plants/node_modules/immutable/dist/immutable.js"],"names":["global","factory","exports","module","define","amd","Immutable","DELETE","SHIFT","SIZE","MASK","NOT_SET","MakeRef","value","SetRef","ref","OwnerID","ensureSize","iter","size","undefined","__iterate","returnTrue","wrapIndex","index","uint32Index","NaN","wholeSlice","begin","end","isNeg","resolveBegin","resolveIndex","resolveEnd","defaultIndex","Infinity","Math","max","min","IS_COLLECTION_SYMBOL","isCollection","maybeCollection","Boolean","IS_KEYED_SYMBOL","isKeyed","maybeKeyed","IS_INDEXED_SYMBOL","isIndexed","maybeIndexed","isAssociative","maybeAssociative","Collection","Seq","KeyedCollection","KeyedSeq","__proto__","prototype","Object","create","constructor","IndexedCollection","IndexedSeq","SetCollection","SetSeq","Keyed","Indexed","Set","IS_SEQ_SYMBOL","isSeq","maybeSeq","IS_RECORD_SYMBOL","isRecord","maybeRecord","isImmutable","maybeImmutable","IS_ORDERED_SYMBOL","isOrdered","maybeOrdered","ITERATE_KEYS","ITERATE_VALUES","ITERATE_ENTRIES","REAL_ITERATOR_SYMBOL","Symbol","iterator","FAUX_ITERATOR_SYMBOL","ITERATOR_SYMBOL","Iterator","next","toString","KEYS","VALUES","ENTRIES","inspect","toSource","iteratorValue","type","k","v","iteratorResult","done","iteratorDone","hasIterator","maybeIterable","getIteratorFn","isIterator","maybeIterator","getIterator","iterable","iteratorFn","call","hasOwnProperty","isArrayLike","Array","isArray","Number","isInteger","length","keys","Collection$$1","emptySequence","toSeq","seqFromValue","__toString","cacheResult","_cache","__iterateUncached","entrySeq","toArray","fn","reverse","cache","i","entry","__iterator","__iteratorUncached","toKeyedSeq","fromEntrySeq","keyedSeqFromValue","toIndexedSeq","indexedSeqFromValue","of","arguments","toSetSeq","ArraySeq","array","_array","get","notSetValue","has","ii","ObjectSeq","object","_object","_keys","key","CollectionSeq","collection","_collection","iterations","step","EMPTY_SEQ","seq","TypeError","maybeIndexedSeqFromValue","IS_MAP_SYMBOL","isMap","maybeMap","isOrderedMap","maybeOrderedMap","isValueObject","maybeValue","equals","hashCode","is","valueA","valueB","valueOf","imul","a","b","c","d","smi","i32","defaultValueOf","hash","o","hashNumber","STRING_HASH_CACHE_MIN_STRLEN","cachedHashString","hashString","hashJSObj","Error","n","string","hashed","stringHashCache","STRING_HASH_CACHE_SIZE","STRING_HASH_CACHE_MAX_SIZE","charCodeAt","obj","usingWeakMap","weakMap","UID_HASH_KEY","canDefineProperty","propertyIsEnumerable","getIENodeHash","objHashUID","set","isExtensible","defineProperty","enumerable","configurable","writable","apply","nodeType","e","node","uniqueID","documentElement","WeakMap","ToKeyedSequence","KeyedSeq$$1","indexed","useKeys","_iter","_useKeys","valueSeq","this$1","reversedSequence","reverseFactory","map","mapper","context","mappedSequence","mapFactory","ToIndexedSequence","IndexedSeq$$1","includes","ToSetSequence","SetSeq$$1","FromEntriesSequence","entries","validateEntry","indexedCollection","cacheResultThrough","flipFactory","flipSequence","makeSequence","flip","filterFactory","predicate","filterSequence","countByFactory","grouper","groups","Map","asMutable","update","asImmutable","groupByFactory","isKeyedIter","OrderedMap","push","coerce","collectionClass","arr","reify","sliceFactory","originalSize","resolvedBegin","resolvedEnd","resolvedSize","sliceSize","sliceSeq","skipped","isSkipping","takeWhileFactory","takeSequence","iterating","skipWhileFactory","skipSequence","skipping","concatFactory","values","isKeyedCollection","iters","concat","filter","singleton","concatSeq","flatten","reduce","sum","flattenFactory","depth","flatSequence","stopped","flatDeep","currentDepth","stack","pop","flatMapFactory","interposeFactory","separator","interposedSequence","sortFactory","comparator","defaultComparator","sort","forEach","maxFactory","maxCompare","comp","zipWithFactory","keyIter","zipper","zipAll","zipSequence","sizes","iterators","isDone","steps","every","s","some","arrCopy","offset","len","newArr","invariant","condition","error","assertNotInfinite","coerceKeyPath","keyPath","isPlainObj","name","isDataStructure","quoteString","JSON","stringify","String","_ignoreError","shallowCopy","from","to","remove","collectionCopy","splice","updateIn","updater","updatedValue","updateInDeeply","inImmutable","existing","wasNotSet","existingValue","newValue","slice","nextExisting","nextUpdated","emptyMap","setIn","setIn$1","removeIn","deleteIn","update$1","updateIn$1","merge","mergeIntoKeyedWith","mergeWith","merger","collections","collection$1","__ownerID","withMutations","mergeIntoCollection","oldVal","merge$1","sources","mergeWithSources","mergeWith$1","mergeDeep","mergeDeepWithSources","mergeDeepWith","deepMergerWith","merged","mergeItem","hasVal","nextVal","deepMerger","oldValue","mergeDeep$1","mergeDeepWith$1","mergeIn","m","mergeDeepIn","mutable","wasAltered","__ensureOwner","__altered","KeyedCollection$$1","keyValues","_root","updateMap","deleteAll","clear","__hash","sortBy","MapIterator","iterate","ownerID","makeMap","MapPrototype","removeAll","result","ArrayMapNode","shift","keyHash","didChangeSize","didAlter","removed","idx","exists","MAX_ARRAY_MAP_SIZE","createNodes","isEditable","newEntries","BitmapIndexedNode","bitmap","nodes","bit","popCount","keyHashFrag","newNode","updateNode","MAX_BITMAP_INDEXED_SIZE","expandNodes","isLeafNode","newBitmap","newNodes","setAt","spliceOut","spliceIn","HashArrayMapNode","count","newCount","MIN_HASH_ARRAY_MAP_SIZE","packNodes","HashCollisionNode","mergeIntoNode","ValueNode","keyMatch","maxIndex","Iterator$$1","_type","_reverse","_stack","mapIteratorFrame","mapIteratorValue","subNode","__prev","prev","root","hash$$1","EMPTY_MAP","newRoot","newSize","idx1","idx2","excluding","packedII","packedNodes","including","expandedNodes","x","val","canEdit","newArray","newLen","after","IS_LIST_SYMBOL","isList","maybeList","List","IndexedCollection$$1","empty","emptyList","makeList","VNode","list","setSize","_origin","listNodeFor","updateList","insert","_capacity","_level","_tail","oldSize","setListBounds","unshift","arguments$1","seqs","argument","iterateList","DONE","ListPrototype","removeBefore","level","originIndex","removingFirst","newChild","oldChild","editable","editableVNode","removeAfter","sizeIndex","left","right","tailPos","getTailOffset","tail","iterateNodeOrLeaf","iterateLeaf","iterateNode","origin","capacity","EMPTY_LIST","newTail","updateVNode","nodeHas","lowerNode","newLowerNode","rawIndex","owner","oldOrigin","oldCapacity","newOrigin","newCapacity","newLevel","offsetShift","oldTailOffset","newTailOffset","oldTail","beginIndex","Map$$1","emptyOrderedMap","_map","_list","updateOrderedMap","newMap","newList","makeOrderedMap","omap","EMPTY_ORDERED_MAP","toMap","IS_STACK_SYMBOL","isStack","maybeStack","Stack","emptyStack","pushAll","head","_head","peek","makeStack","StackPrototype","unshiftAll","EMPTY_STACK","IS_SET_SYMBOL","isSet","maybeSet","isOrderedSet","maybeOrderedSet","deepEqual","notAssociative","flipped","_","allEqual","bSize","mixin","ctor","methods","keyCopier","getOwnPropertySymbols","toJS","result$1","SetCollection$$1","emptySet","add","fromKeys","keySeq","intersect","sets","SetPrototype","union","updateSet","removes","adds","mapped","toRemove","subtract","OrderedSet","__empty","__make","makeSet","EMPTY_SET","Range","start","abs","_start","_end","_step","ceil","EMPTY_RANGE","searchValue","possibleIndex","floor","indexOf","offsetValue","lastIndexOf","other","getIn","searchKeyPath","getIn$1","hasIn","hasIn$1","toObject","isIterable","useTuples","toJS$1","toOrderedMap","toOrderedSet","toSet","toStack","toList","__toStringMapper","join","returnValue","find","findEntry","sideEffect","bind","joined","isFirst","reduce$1","reducer","initialReduction","reduceRight","not","butLast","isEmpty","countBy","entriesSequence","entryMapper","filterNot","found","findKey","findLast","findLastEntry","findLastKey","first","flatMap","searchKey","groupBy","isSubset","isSuperset","keyOf","keyMapper","last","lastKeyOf","maxBy","neg","defaultNegComparator","minBy","rest","skip","amount","skipLast","skipWhile","skipUntil","take","takeLast","takeWhile","takeUntil","hashCollection","CollectionPrototype","toJSON","chain","contains","mapEntries","mapKeys","KeyedCollectionPrototype","findIndex","removeNum","numArgs","spliced","findLastIndex","interpose","interleave","zipped","interleaved","zip","defaultZipper","zipWith","IndexedCollectionPrototype","reduction","useFirst","ordered","keyed","h","hashMerge","murmurHashOfSize","Set$$1","emptyOrderedSet","OrderedSetPrototype","makeOrderedSet","EMPTY_ORDERED_SET","Record","defaultValues","hasInitialized","RecordType","indices","RecordTypePrototype","_indices","_name","_defaultValues","propName","console","warn","recordName","setProp","_values","l","RecordPrototype","displayName","str","recordSeq","newValues","makeRecord","getDescriptiveName","likeRecord","record","getPrototypeOf","Repeat","times","_value","EMPTY_REPEAT","fromJS","converter","fromJSWith","defaultConverter","parentValue","converted","version","Iterable","default"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.Immutable = {})));\n}(this, (function (exports) { 'use strict';\n\n  // Used for setting prototype methods that IE8 chokes on.\n  var DELETE = 'delete';\n\n  // Constants describing the size of trie nodes.\n  var SHIFT = 5; // Resulted in best performance after ______?\n  var SIZE = 1 << SHIFT;\n  var MASK = SIZE - 1;\n\n  // A consistent shared value representing \"not set\" which equals nothing other\n  // than itself, and nothing that could be provided externally.\n  var NOT_SET = {};\n\n  // Boolean references, Rough equivalent of `bool &`.\n  function MakeRef() {\n    return { value: false };\n  }\n\n  function SetRef(ref) {\n    if (ref) {\n      ref.value = true;\n    }\n  }\n\n  // A function which returns a value representing an \"owner\" for transient writes\n  // to tries. The return value will only ever equal itself, and will not equal\n  // the return of any subsequent call of this function.\n  function OwnerID() {}\n\n  function ensureSize(iter) {\n    if (iter.size === undefined) {\n      iter.size = iter.__iterate(returnTrue);\n    }\n    return iter.size;\n  }\n\n  function wrapIndex(iter, index) {\n    // This implements \"is array index\" which the ECMAString spec defines as:\n    //\n    //     A String property name P is an array index if and only if\n    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n    //     to 2^32âˆ’1.\n    //\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n    if (typeof index !== 'number') {\n      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n        return NaN;\n      }\n      index = uint32Index;\n    }\n    return index < 0 ? ensureSize(iter) + index : index;\n  }\n\n  function returnTrue() {\n    return true;\n  }\n\n  function wholeSlice(begin, end, size) {\n    return (\n      ((begin === 0 && !isNeg(begin)) ||\n        (size !== undefined && begin <= -size)) &&\n      (end === undefined || (size !== undefined && end >= size))\n    );\n  }\n\n  function resolveBegin(begin, size) {\n    return resolveIndex(begin, size, 0);\n  }\n\n  function resolveEnd(end, size) {\n    return resolveIndex(end, size, size);\n  }\n\n  function resolveIndex(index, size, defaultIndex) {\n    // Sanitize indices using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    return index === undefined\n      ? defaultIndex\n      : isNeg(index)\n        ? size === Infinity\n          ? size\n          : Math.max(0, size + index) | 0\n        : size === undefined || size === index\n          ? index\n          : Math.min(size, index) | 0;\n  }\n\n  function isNeg(value) {\n    // Account for -0 which is negative, but not less than 0.\n    return value < 0 || (value === 0 && 1 / value === -Infinity);\n  }\n\n  // Note: value is unchanged to not break immutable-devtools.\n  var IS_COLLECTION_SYMBOL = '@@__IMMUTABLE_ITERABLE__@@';\n\n  function isCollection(maybeCollection) {\n    return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);\n  }\n\n  var IS_KEYED_SYMBOL = '@@__IMMUTABLE_KEYED__@@';\n\n  function isKeyed(maybeKeyed) {\n    return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);\n  }\n\n  var IS_INDEXED_SYMBOL = '@@__IMMUTABLE_INDEXED__@@';\n\n  function isIndexed(maybeIndexed) {\n    return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);\n  }\n\n  function isAssociative(maybeAssociative) {\n    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n  }\n\n  var Collection = function Collection(value) {\n    return isCollection(value) ? value : Seq(value);\n  };\n\n  var KeyedCollection = /*@__PURE__*/(function (Collection) {\n    function KeyedCollection(value) {\n      return isKeyed(value) ? value : KeyedSeq(value);\n    }\n\n    if ( Collection ) KeyedCollection.__proto__ = Collection;\n    KeyedCollection.prototype = Object.create( Collection && Collection.prototype );\n    KeyedCollection.prototype.constructor = KeyedCollection;\n\n    return KeyedCollection;\n  }(Collection));\n\n  var IndexedCollection = /*@__PURE__*/(function (Collection) {\n    function IndexedCollection(value) {\n      return isIndexed(value) ? value : IndexedSeq(value);\n    }\n\n    if ( Collection ) IndexedCollection.__proto__ = Collection;\n    IndexedCollection.prototype = Object.create( Collection && Collection.prototype );\n    IndexedCollection.prototype.constructor = IndexedCollection;\n\n    return IndexedCollection;\n  }(Collection));\n\n  var SetCollection = /*@__PURE__*/(function (Collection) {\n    function SetCollection(value) {\n      return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);\n    }\n\n    if ( Collection ) SetCollection.__proto__ = Collection;\n    SetCollection.prototype = Object.create( Collection && Collection.prototype );\n    SetCollection.prototype.constructor = SetCollection;\n\n    return SetCollection;\n  }(Collection));\n\n  Collection.Keyed = KeyedCollection;\n  Collection.Indexed = IndexedCollection;\n  Collection.Set = SetCollection;\n\n  var IS_SEQ_SYMBOL = '@@__IMMUTABLE_SEQ__@@';\n\n  function isSeq(maybeSeq) {\n    return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);\n  }\n\n  var IS_RECORD_SYMBOL = '@@__IMMUTABLE_RECORD__@@';\n\n  function isRecord(maybeRecord) {\n    return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);\n  }\n\n  function isImmutable(maybeImmutable) {\n    return isCollection(maybeImmutable) || isRecord(maybeImmutable);\n  }\n\n  var IS_ORDERED_SYMBOL = '@@__IMMUTABLE_ORDERED__@@';\n\n  function isOrdered(maybeOrdered) {\n    return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);\n  }\n\n  var ITERATE_KEYS = 0;\n  var ITERATE_VALUES = 1;\n  var ITERATE_ENTRIES = 2;\n\n  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\n  var Iterator = function Iterator(next) {\n    this.next = next;\n  };\n\n  Iterator.prototype.toString = function toString () {\n    return '[Iterator]';\n  };\n\n  Iterator.KEYS = ITERATE_KEYS;\n  Iterator.VALUES = ITERATE_VALUES;\n  Iterator.ENTRIES = ITERATE_ENTRIES;\n\n  Iterator.prototype.inspect = Iterator.prototype.toSource = function() {\n    return this.toString();\n  };\n  Iterator.prototype[ITERATOR_SYMBOL] = function() {\n    return this;\n  };\n\n  function iteratorValue(type, k, v, iteratorResult) {\n    var value = type === 0 ? k : type === 1 ? v : [k, v];\n    iteratorResult\n      ? (iteratorResult.value = value)\n      : (iteratorResult = {\n          value: value,\n          done: false,\n        });\n    return iteratorResult;\n  }\n\n  function iteratorDone() {\n    return { value: undefined, done: true };\n  }\n\n  function hasIterator(maybeIterable) {\n    return !!getIteratorFn(maybeIterable);\n  }\n\n  function isIterator(maybeIterator) {\n    return maybeIterator && typeof maybeIterator.next === 'function';\n  }\n\n  function getIterator(iterable) {\n    var iteratorFn = getIteratorFn(iterable);\n    return iteratorFn && iteratorFn.call(iterable);\n  }\n\n  function getIteratorFn(iterable) {\n    var iteratorFn =\n      iterable &&\n      ((REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n        iterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  function isArrayLike(value) {\n    if (Array.isArray(value) || typeof value === 'string') {\n      return true;\n    }\n\n    return (\n      value &&\n      typeof value === 'object' &&\n      Number.isInteger(value.length) &&\n      value.length >= 0 &&\n      (value.length === 0\n        ? // Only {length: 0} is considered Array-like.\n          Object.keys(value).length === 1\n        : // An object is only Array-like if it has a property where the last value\n          // in the array-like may be found (which could be undefined).\n          value.hasOwnProperty(value.length - 1))\n    );\n  }\n\n  var Seq = /*@__PURE__*/(function (Collection$$1) {\n    function Seq(value) {\n      return value === null || value === undefined\n        ? emptySequence()\n        : isImmutable(value)\n          ? value.toSeq()\n          : seqFromValue(value);\n    }\n\n    if ( Collection$$1 ) Seq.__proto__ = Collection$$1;\n    Seq.prototype = Object.create( Collection$$1 && Collection$$1.prototype );\n    Seq.prototype.constructor = Seq;\n\n    Seq.prototype.toSeq = function toSeq () {\n      return this;\n    };\n\n    Seq.prototype.toString = function toString () {\n      return this.__toString('Seq {', '}');\n    };\n\n    Seq.prototype.cacheResult = function cacheResult () {\n      if (!this._cache && this.__iterateUncached) {\n        this._cache = this.entrySeq().toArray();\n        this.size = this._cache.length;\n      }\n      return this;\n    };\n\n    // abstract __iterateUncached(fn, reverse)\n\n    Seq.prototype.__iterate = function __iterate (fn, reverse) {\n      var cache = this._cache;\n      if (cache) {\n        var size = cache.length;\n        var i = 0;\n        while (i !== size) {\n          var entry = cache[reverse ? size - ++i : i++];\n          if (fn(entry[1], entry[0], this) === false) {\n            break;\n          }\n        }\n        return i;\n      }\n      return this.__iterateUncached(fn, reverse);\n    };\n\n    // abstract __iteratorUncached(type, reverse)\n\n    Seq.prototype.__iterator = function __iterator (type, reverse) {\n      var cache = this._cache;\n      if (cache) {\n        var size = cache.length;\n        var i = 0;\n        return new Iterator(function () {\n          if (i === size) {\n            return iteratorDone();\n          }\n          var entry = cache[reverse ? size - ++i : i++];\n          return iteratorValue(type, entry[0], entry[1]);\n        });\n      }\n      return this.__iteratorUncached(type, reverse);\n    };\n\n    return Seq;\n  }(Collection));\n\n  var KeyedSeq = /*@__PURE__*/(function (Seq) {\n    function KeyedSeq(value) {\n      return value === null || value === undefined\n        ? emptySequence().toKeyedSeq()\n        : isCollection(value)\n          ? isKeyed(value)\n            ? value.toSeq()\n            : value.fromEntrySeq()\n          : isRecord(value)\n            ? value.toSeq()\n            : keyedSeqFromValue(value);\n    }\n\n    if ( Seq ) KeyedSeq.__proto__ = Seq;\n    KeyedSeq.prototype = Object.create( Seq && Seq.prototype );\n    KeyedSeq.prototype.constructor = KeyedSeq;\n\n    KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq () {\n      return this;\n    };\n\n    return KeyedSeq;\n  }(Seq));\n\n  var IndexedSeq = /*@__PURE__*/(function (Seq) {\n    function IndexedSeq(value) {\n      return value === null || value === undefined\n        ? emptySequence()\n        : isCollection(value)\n          ? isKeyed(value)\n            ? value.entrySeq()\n            : value.toIndexedSeq()\n          : isRecord(value)\n            ? value.toSeq().entrySeq()\n            : indexedSeqFromValue(value);\n    }\n\n    if ( Seq ) IndexedSeq.__proto__ = Seq;\n    IndexedSeq.prototype = Object.create( Seq && Seq.prototype );\n    IndexedSeq.prototype.constructor = IndexedSeq;\n\n    IndexedSeq.of = function of (/*...values*/) {\n      return IndexedSeq(arguments);\n    };\n\n    IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq () {\n      return this;\n    };\n\n    IndexedSeq.prototype.toString = function toString () {\n      return this.__toString('Seq [', ']');\n    };\n\n    return IndexedSeq;\n  }(Seq));\n\n  var SetSeq = /*@__PURE__*/(function (Seq) {\n    function SetSeq(value) {\n      return (isCollection(value) && !isAssociative(value)\n        ? value\n        : IndexedSeq(value)\n      ).toSetSeq();\n    }\n\n    if ( Seq ) SetSeq.__proto__ = Seq;\n    SetSeq.prototype = Object.create( Seq && Seq.prototype );\n    SetSeq.prototype.constructor = SetSeq;\n\n    SetSeq.of = function of (/*...values*/) {\n      return SetSeq(arguments);\n    };\n\n    SetSeq.prototype.toSetSeq = function toSetSeq () {\n      return this;\n    };\n\n    return SetSeq;\n  }(Seq));\n\n  Seq.isSeq = isSeq;\n  Seq.Keyed = KeyedSeq;\n  Seq.Set = SetSeq;\n  Seq.Indexed = IndexedSeq;\n\n  Seq.prototype[IS_SEQ_SYMBOL] = true;\n\n  // #pragma Root Sequences\n\n  var ArraySeq = /*@__PURE__*/(function (IndexedSeq) {\n    function ArraySeq(array) {\n      this._array = array;\n      this.size = array.length;\n    }\n\n    if ( IndexedSeq ) ArraySeq.__proto__ = IndexedSeq;\n    ArraySeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n    ArraySeq.prototype.constructor = ArraySeq;\n\n    ArraySeq.prototype.get = function get (index, notSetValue) {\n      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n    };\n\n    ArraySeq.prototype.__iterate = function __iterate (fn, reverse) {\n      var array = this._array;\n      var size = array.length;\n      var i = 0;\n      while (i !== size) {\n        var ii = reverse ? size - ++i : i++;\n        if (fn(array[ii], ii, this) === false) {\n          break;\n        }\n      }\n      return i;\n    };\n\n    ArraySeq.prototype.__iterator = function __iterator (type, reverse) {\n      var array = this._array;\n      var size = array.length;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n        var ii = reverse ? size - ++i : i++;\n        return iteratorValue(type, ii, array[ii]);\n      });\n    };\n\n    return ArraySeq;\n  }(IndexedSeq));\n\n  var ObjectSeq = /*@__PURE__*/(function (KeyedSeq) {\n    function ObjectSeq(object) {\n      var keys = Object.keys(object);\n      this._object = object;\n      this._keys = keys;\n      this.size = keys.length;\n    }\n\n    if ( KeyedSeq ) ObjectSeq.__proto__ = KeyedSeq;\n    ObjectSeq.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );\n    ObjectSeq.prototype.constructor = ObjectSeq;\n\n    ObjectSeq.prototype.get = function get (key, notSetValue) {\n      if (notSetValue !== undefined && !this.has(key)) {\n        return notSetValue;\n      }\n      return this._object[key];\n    };\n\n    ObjectSeq.prototype.has = function has (key) {\n      return hasOwnProperty.call(this._object, key);\n    };\n\n    ObjectSeq.prototype.__iterate = function __iterate (fn, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var size = keys.length;\n      var i = 0;\n      while (i !== size) {\n        var key = keys[reverse ? size - ++i : i++];\n        if (fn(object[key], key, this) === false) {\n          break;\n        }\n      }\n      return i;\n    };\n\n    ObjectSeq.prototype.__iterator = function __iterator (type, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var size = keys.length;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n        var key = keys[reverse ? size - ++i : i++];\n        return iteratorValue(type, key, object[key]);\n      });\n    };\n\n    return ObjectSeq;\n  }(KeyedSeq));\n  ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;\n\n  var CollectionSeq = /*@__PURE__*/(function (IndexedSeq) {\n    function CollectionSeq(collection) {\n      this._collection = collection;\n      this.size = collection.length || collection.size;\n    }\n\n    if ( IndexedSeq ) CollectionSeq.__proto__ = IndexedSeq;\n    CollectionSeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n    CollectionSeq.prototype.constructor = CollectionSeq;\n\n    CollectionSeq.prototype.__iterateUncached = function __iterateUncached (fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var collection = this._collection;\n      var iterator = getIterator(collection);\n      var iterations = 0;\n      if (isIterator(iterator)) {\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (fn(step.value, iterations++, this) === false) {\n            break;\n          }\n        }\n      }\n      return iterations;\n    };\n\n    CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached (type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var collection = this._collection;\n      var iterator = getIterator(collection);\n      if (!isIterator(iterator)) {\n        return new Iterator(iteratorDone);\n      }\n      var iterations = 0;\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, iterations++, step.value);\n      });\n    };\n\n    return CollectionSeq;\n  }(IndexedSeq));\n\n  // # pragma Helper functions\n\n  var EMPTY_SEQ;\n\n  function emptySequence() {\n    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n  }\n\n  function keyedSeqFromValue(value) {\n    var seq = Array.isArray(value)\n      ? new ArraySeq(value)\n      : hasIterator(value)\n        ? new CollectionSeq(value)\n        : undefined;\n    if (seq) {\n      return seq.fromEntrySeq();\n    }\n    if (typeof value === 'object') {\n      return new ObjectSeq(value);\n    }\n    throw new TypeError(\n      'Expected Array or collection object of [k, v] entries, or keyed object: ' +\n        value\n    );\n  }\n\n  function indexedSeqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (seq) {\n      return seq;\n    }\n    throw new TypeError(\n      'Expected Array or collection object of values: ' + value\n    );\n  }\n\n  function seqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (seq) {\n      return seq;\n    }\n    if (typeof value === 'object') {\n      return new ObjectSeq(value);\n    }\n    throw new TypeError(\n      'Expected Array or collection object of values, or keyed object: ' + value\n    );\n  }\n\n  function maybeIndexedSeqFromValue(value) {\n    return isArrayLike(value)\n      ? new ArraySeq(value)\n      : hasIterator(value)\n        ? new CollectionSeq(value)\n        : undefined;\n  }\n\n  var IS_MAP_SYMBOL = '@@__IMMUTABLE_MAP__@@';\n\n  function isMap(maybeMap) {\n    return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);\n  }\n\n  function isOrderedMap(maybeOrderedMap) {\n    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n  }\n\n  function isValueObject(maybeValue) {\n    return Boolean(\n      maybeValue &&\n        typeof maybeValue.equals === 'function' &&\n        typeof maybeValue.hashCode === 'function'\n    );\n  }\n\n  /**\n   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n   *\n   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n   * value, which is different from the algorithm described by\n   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n   *\n   * This is extended further to allow Objects to describe the values they\n   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n   *\n   * Note: because of this extension, the key equality of Immutable.Map and the\n   * value equality of Immutable.Set will differ from ES6 Map and Set.\n   *\n   * ### Defining custom values\n   *\n   * The easiest way to describe the value an object represents is by implementing\n   * `valueOf`. For example, `Date` represents a value by returning a unix\n   * timestamp for `valueOf`:\n   *\n   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n   *     var date2 = new Date(1234567890000);\n   *     date1.valueOf(); // 1234567890000\n   *     assert( date1 !== date2 );\n   *     assert( Immutable.is( date1, date2 ) );\n   *\n   * Note: overriding `valueOf` may have other implications if you use this object\n   * where JavaScript expects a primitive, such as implicit string coercion.\n   *\n   * For more complex types, especially collections, implementing `valueOf` may\n   * not be performant. An alternative is to implement `equals` and `hashCode`.\n   *\n   * `equals` takes another object, presumably of similar type, and returns true\n   * if it is equal. Equality is symmetrical, so the same result should be\n   * returned if this and the argument are flipped.\n   *\n   *     assert( a.equals(b) === b.equals(a) );\n   *\n   * `hashCode` returns a 32bit integer number representing the object which will\n   * be used to determine how to store the value object in a Map or Set. You must\n   * provide both or neither methods, one must not exist without the other.\n   *\n   * Also, an important relationship between these methods must be upheld: if two\n   * values are equal, they *must* return the same hashCode. If the values are not\n   * equal, they might have the same hashCode; this is called a hash collision,\n   * and while undesirable for performance reasons, it is acceptable.\n   *\n   *     if (a.equals(b)) {\n   *       assert( a.hashCode() === b.hashCode() );\n   *     }\n   *\n   * All Immutable collections are Value Objects: they implement `equals()`\n   * and `hashCode()`.\n   */\n  function is(valueA, valueB) {\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n    if (\n      typeof valueA.valueOf === 'function' &&\n      typeof valueB.valueOf === 'function'\n    ) {\n      valueA = valueA.valueOf();\n      valueB = valueB.valueOf();\n      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n        return true;\n      }\n      if (!valueA || !valueB) {\n        return false;\n      }\n    }\n    return !!(\n      isValueObject(valueA) &&\n      isValueObject(valueB) &&\n      valueA.equals(valueB)\n    );\n  }\n\n  var imul =\n    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2\n      ? Math.imul\n      : function imul(a, b) {\n          a |= 0; // int\n          b |= 0; // int\n          var c = a & 0xffff;\n          var d = b & 0xffff;\n          // Shift by 0 fixes the sign on the high part.\n          return (c * d + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0)) | 0; // int\n        };\n\n  // v8 has an optimization for storing 31-bit signed numbers.\n  // Values which have either 00 or 11 as the high order bits qualify.\n  // This function drops the highest order bit in a signed number, maintaining\n  // the sign bit.\n  function smi(i32) {\n    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xbfffffff);\n  }\n\n  var defaultValueOf = Object.prototype.valueOf;\n\n  function hash(o) {\n    switch (typeof o) {\n      case 'boolean':\n        // The hash values for built-in constants are a 1 value for each 5-byte\n        // shift region expect for the first, which encodes the value. This\n        // reduces the odds of a hash collision for these common values.\n        return o ? 0x42108421 : 0x42108420;\n      case 'number':\n        return hashNumber(o);\n      case 'string':\n        return o.length > STRING_HASH_CACHE_MIN_STRLEN\n          ? cachedHashString(o)\n          : hashString(o);\n      case 'object':\n      case 'function':\n        if (o === null) {\n          return 0x42108422;\n        }\n        if (typeof o.hashCode === 'function') {\n          // Drop any high bits from accidentally long hash codes.\n          return smi(o.hashCode(o));\n        }\n        if (o.valueOf !== defaultValueOf && typeof o.valueOf === 'function') {\n          o = o.valueOf(o);\n        }\n        return hashJSObj(o);\n      case 'undefined':\n        return 0x42108423;\n      default:\n        if (typeof o.toString === 'function') {\n          return hashString(o.toString());\n        }\n        throw new Error('Value type ' + typeof o + ' cannot be hashed.');\n    }\n  }\n\n  // Compress arbitrarily large numbers into smi hashes.\n  function hashNumber(n) {\n    if (n !== n || n === Infinity) {\n      return 0;\n    }\n    var hash = n | 0;\n    if (hash !== n) {\n      hash ^= n * 0xffffffff;\n    }\n    while (n > 0xffffffff) {\n      n /= 0xffffffff;\n      hash ^= n;\n    }\n    return smi(hash);\n  }\n\n  function cachedHashString(string) {\n    var hashed = stringHashCache[string];\n    if (hashed === undefined) {\n      hashed = hashString(string);\n      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n        STRING_HASH_CACHE_SIZE = 0;\n        stringHashCache = {};\n      }\n      STRING_HASH_CACHE_SIZE++;\n      stringHashCache[string] = hashed;\n    }\n    return hashed;\n  }\n\n  // http://jsperf.com/hashing-strings\n  function hashString(string) {\n    // This is the hash from JVM\n    // The hash code for a string is computed as\n    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n    // where s[i] is the ith character of the string and n is the length of\n    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n    // (exclusive) by dropping high bits.\n    var hashed = 0;\n    for (var ii = 0; ii < string.length; ii++) {\n      hashed = (31 * hashed + string.charCodeAt(ii)) | 0;\n    }\n    return smi(hashed);\n  }\n\n  function hashJSObj(obj) {\n    var hashed;\n    if (usingWeakMap) {\n      hashed = weakMap.get(obj);\n      if (hashed !== undefined) {\n        return hashed;\n      }\n    }\n\n    hashed = obj[UID_HASH_KEY];\n    if (hashed !== undefined) {\n      return hashed;\n    }\n\n    if (!canDefineProperty) {\n      hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n      if (hashed !== undefined) {\n        return hashed;\n      }\n\n      hashed = getIENodeHash(obj);\n      if (hashed !== undefined) {\n        return hashed;\n      }\n    }\n\n    hashed = ++objHashUID;\n    if (objHashUID & 0x40000000) {\n      objHashUID = 0;\n    }\n\n    if (usingWeakMap) {\n      weakMap.set(obj, hashed);\n    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n      throw new Error('Non-extensible objects are not allowed as keys.');\n    } else if (canDefineProperty) {\n      Object.defineProperty(obj, UID_HASH_KEY, {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n        value: hashed,\n      });\n    } else if (\n      obj.propertyIsEnumerable !== undefined &&\n      obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable\n    ) {\n      // Since we can't define a non-enumerable property on the object\n      // we'll hijack one of the less-used non-enumerable properties to\n      // save our hash on it. Since this is a function it will not show up in\n      // `JSON.stringify` which is what we want.\n      obj.propertyIsEnumerable = function() {\n        return this.constructor.prototype.propertyIsEnumerable.apply(\n          this,\n          arguments\n        );\n      };\n      obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;\n    } else if (obj.nodeType !== undefined) {\n      // At this point we couldn't get the IE `uniqueID` to use as a hash\n      // and we couldn't use a non-enumerable property to exploit the\n      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n      // itself.\n      obj[UID_HASH_KEY] = hashed;\n    } else {\n      throw new Error('Unable to set a non-enumerable property on object.');\n    }\n\n    return hashed;\n  }\n\n  // Get references to ES5 object methods.\n  var isExtensible = Object.isExtensible;\n\n  // True if Object.defineProperty works as expected. IE8 fails this test.\n  var canDefineProperty = (function() {\n    try {\n      Object.defineProperty({}, '@', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  })();\n\n  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n  // and avoid memory leaks from the IE cloneNode bug.\n  function getIENodeHash(node) {\n    if (node && node.nodeType > 0) {\n      switch (node.nodeType) {\n        case 1: // Element\n          return node.uniqueID;\n        case 9: // Document\n          return node.documentElement && node.documentElement.uniqueID;\n      }\n    }\n  }\n\n  // If possible, use a WeakMap.\n  var usingWeakMap = typeof WeakMap === 'function';\n  var weakMap;\n  if (usingWeakMap) {\n    weakMap = new WeakMap();\n  }\n\n  var objHashUID = 0;\n\n  var UID_HASH_KEY = '__immutablehash__';\n  if (typeof Symbol === 'function') {\n    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n  }\n\n  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n  var STRING_HASH_CACHE_MAX_SIZE = 255;\n  var STRING_HASH_CACHE_SIZE = 0;\n  var stringHashCache = {};\n\n  var ToKeyedSequence = /*@__PURE__*/(function (KeyedSeq$$1) {\n    function ToKeyedSequence(indexed, useKeys) {\n      this._iter = indexed;\n      this._useKeys = useKeys;\n      this.size = indexed.size;\n    }\n\n    if ( KeyedSeq$$1 ) ToKeyedSequence.__proto__ = KeyedSeq$$1;\n    ToKeyedSequence.prototype = Object.create( KeyedSeq$$1 && KeyedSeq$$1.prototype );\n    ToKeyedSequence.prototype.constructor = ToKeyedSequence;\n\n    ToKeyedSequence.prototype.get = function get (key, notSetValue) {\n      return this._iter.get(key, notSetValue);\n    };\n\n    ToKeyedSequence.prototype.has = function has (key) {\n      return this._iter.has(key);\n    };\n\n    ToKeyedSequence.prototype.valueSeq = function valueSeq () {\n      return this._iter.valueSeq();\n    };\n\n    ToKeyedSequence.prototype.reverse = function reverse () {\n      var this$1 = this;\n\n      var reversedSequence = reverseFactory(this, true);\n      if (!this._useKeys) {\n        reversedSequence.valueSeq = function () { return this$1._iter.toSeq().reverse(); };\n      }\n      return reversedSequence;\n    };\n\n    ToKeyedSequence.prototype.map = function map (mapper, context) {\n      var this$1 = this;\n\n      var mappedSequence = mapFactory(this, mapper, context);\n      if (!this._useKeys) {\n        mappedSequence.valueSeq = function () { return this$1._iter.toSeq().map(mapper, context); };\n      }\n      return mappedSequence;\n    };\n\n    ToKeyedSequence.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      return this._iter.__iterate(function (v, k) { return fn(v, k, this$1); }, reverse);\n    };\n\n    ToKeyedSequence.prototype.__iterator = function __iterator (type, reverse) {\n      return this._iter.__iterator(type, reverse);\n    };\n\n    return ToKeyedSequence;\n  }(KeyedSeq));\n  ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;\n\n  var ToIndexedSequence = /*@__PURE__*/(function (IndexedSeq$$1) {\n    function ToIndexedSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    if ( IndexedSeq$$1 ) ToIndexedSequence.__proto__ = IndexedSeq$$1;\n    ToIndexedSequence.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );\n    ToIndexedSequence.prototype.constructor = ToIndexedSequence;\n\n    ToIndexedSequence.prototype.includes = function includes (value) {\n      return this._iter.includes(value);\n    };\n\n    ToIndexedSequence.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      var i = 0;\n      reverse && ensureSize(this);\n      return this._iter.__iterate(\n        function (v) { return fn(v, reverse ? this$1.size - ++i : i++, this$1); },\n        reverse\n      );\n    };\n\n    ToIndexedSequence.prototype.__iterator = function __iterator (type, reverse) {\n      var this$1 = this;\n\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var i = 0;\n      reverse && ensureSize(this);\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done\n          ? step\n          : iteratorValue(\n              type,\n              reverse ? this$1.size - ++i : i++,\n              step.value,\n              step\n            );\n      });\n    };\n\n    return ToIndexedSequence;\n  }(IndexedSeq));\n\n  var ToSetSequence = /*@__PURE__*/(function (SetSeq$$1) {\n    function ToSetSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    if ( SetSeq$$1 ) ToSetSequence.__proto__ = SetSeq$$1;\n    ToSetSequence.prototype = Object.create( SetSeq$$1 && SetSeq$$1.prototype );\n    ToSetSequence.prototype.constructor = ToSetSequence;\n\n    ToSetSequence.prototype.has = function has (key) {\n      return this._iter.includes(key);\n    };\n\n    ToSetSequence.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      return this._iter.__iterate(function (v) { return fn(v, v, this$1); }, reverse);\n    };\n\n    ToSetSequence.prototype.__iterator = function __iterator (type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done\n          ? step\n          : iteratorValue(type, step.value, step.value, step);\n      });\n    };\n\n    return ToSetSequence;\n  }(SetSeq));\n\n  var FromEntriesSequence = /*@__PURE__*/(function (KeyedSeq$$1) {\n    function FromEntriesSequence(entries) {\n      this._iter = entries;\n      this.size = entries.size;\n    }\n\n    if ( KeyedSeq$$1 ) FromEntriesSequence.__proto__ = KeyedSeq$$1;\n    FromEntriesSequence.prototype = Object.create( KeyedSeq$$1 && KeyedSeq$$1.prototype );\n    FromEntriesSequence.prototype.constructor = FromEntriesSequence;\n\n    FromEntriesSequence.prototype.entrySeq = function entrySeq () {\n      return this._iter.toSeq();\n    };\n\n    FromEntriesSequence.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      return this._iter.__iterate(function (entry) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedCollection = isCollection(entry);\n          return fn(\n            indexedCollection ? entry.get(1) : entry[1],\n            indexedCollection ? entry.get(0) : entry[0],\n            this$1\n          );\n        }\n      }, reverse);\n    };\n\n    FromEntriesSequence.prototype.__iterator = function __iterator (type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function () {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          // Check if entry exists first so array access doesn't throw for holes\n          // in the parent iteration.\n          if (entry) {\n            validateEntry(entry);\n            var indexedCollection = isCollection(entry);\n            return iteratorValue(\n              type,\n              indexedCollection ? entry.get(0) : entry[0],\n              indexedCollection ? entry.get(1) : entry[1],\n              step\n            );\n          }\n        }\n      });\n    };\n\n    return FromEntriesSequence;\n  }(KeyedSeq));\n\n  ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;\n\n  function flipFactory(collection) {\n    var flipSequence = makeSequence(collection);\n    flipSequence._iter = collection;\n    flipSequence.size = collection.size;\n    flipSequence.flip = function () { return collection; };\n    flipSequence.reverse = function() {\n      var reversedSequence = collection.reverse.apply(this); // super.reverse()\n      reversedSequence.flip = function () { return collection.reverse(); };\n      return reversedSequence;\n    };\n    flipSequence.has = function (key) { return collection.includes(key); };\n    flipSequence.includes = function (key) { return collection.has(key); };\n    flipSequence.cacheResult = cacheResultThrough;\n    flipSequence.__iterateUncached = function(fn, reverse) {\n      var this$1 = this;\n\n      return collection.__iterate(function (v, k) { return fn(k, v, this$1) !== false; }, reverse);\n    };\n    flipSequence.__iteratorUncached = function(type, reverse) {\n      if (type === ITERATE_ENTRIES) {\n        var iterator = collection.__iterator(type, reverse);\n        return new Iterator(function () {\n          var step = iterator.next();\n          if (!step.done) {\n            var k = step.value[0];\n            step.value[0] = step.value[1];\n            step.value[1] = k;\n          }\n          return step;\n        });\n      }\n      return collection.__iterator(\n        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n        reverse\n      );\n    };\n    return flipSequence;\n  }\n\n  function mapFactory(collection, mapper, context) {\n    var mappedSequence = makeSequence(collection);\n    mappedSequence.size = collection.size;\n    mappedSequence.has = function (key) { return collection.has(key); };\n    mappedSequence.get = function (key, notSetValue) {\n      var v = collection.get(key, NOT_SET);\n      return v === NOT_SET\n        ? notSetValue\n        : mapper.call(context, v, key, collection);\n    };\n    mappedSequence.__iterateUncached = function(fn, reverse) {\n      var this$1 = this;\n\n      return collection.__iterate(\n        function (v, k, c) { return fn(mapper.call(context, v, k, c), k, this$1) !== false; },\n        reverse\n      );\n    };\n    mappedSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        return iteratorValue(\n          type,\n          key,\n          mapper.call(context, entry[1], key, collection),\n          step\n        );\n      });\n    };\n    return mappedSequence;\n  }\n\n  function reverseFactory(collection, useKeys) {\n    var this$1 = this;\n\n    var reversedSequence = makeSequence(collection);\n    reversedSequence._iter = collection;\n    reversedSequence.size = collection.size;\n    reversedSequence.reverse = function () { return collection; };\n    if (collection.flip) {\n      reversedSequence.flip = function() {\n        var flipSequence = flipFactory(collection);\n        flipSequence.reverse = function () { return collection.flip(); };\n        return flipSequence;\n      };\n    }\n    reversedSequence.get = function (key, notSetValue) { return collection.get(useKeys ? key : -1 - key, notSetValue); };\n    reversedSequence.has = function (key) { return collection.has(useKeys ? key : -1 - key); };\n    reversedSequence.includes = function (value) { return collection.includes(value); };\n    reversedSequence.cacheResult = cacheResultThrough;\n    reversedSequence.__iterate = function(fn, reverse) {\n      var this$1 = this;\n\n      var i = 0;\n      reverse && ensureSize(collection);\n      return collection.__iterate(\n        function (v, k) { return fn(v, useKeys ? k : reverse ? this$1.size - ++i : i++, this$1); },\n        !reverse\n      );\n    };\n    reversedSequence.__iterator = function (type, reverse) {\n      var i = 0;\n      reverse && ensureSize(collection);\n      var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        return iteratorValue(\n          type,\n          useKeys ? entry[0] : reverse ? this$1.size - ++i : i++,\n          entry[1],\n          step\n        );\n      });\n    };\n    return reversedSequence;\n  }\n\n  function filterFactory(collection, predicate, context, useKeys) {\n    var filterSequence = makeSequence(collection);\n    if (useKeys) {\n      filterSequence.has = function (key) {\n        var v = collection.get(key, NOT_SET);\n        return v !== NOT_SET && !!predicate.call(context, v, key, collection);\n      };\n      filterSequence.get = function (key, notSetValue) {\n        var v = collection.get(key, NOT_SET);\n        return v !== NOT_SET && predicate.call(context, v, key, collection)\n          ? v\n          : notSetValue;\n      };\n    }\n    filterSequence.__iterateUncached = function(fn, reverse) {\n      var this$1 = this;\n\n      var iterations = 0;\n      collection.__iterate(function (v, k, c) {\n        if (predicate.call(context, v, k, c)) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$1);\n        }\n      }, reverse);\n      return iterations;\n    };\n    filterSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n      var iterations = 0;\n      return new Iterator(function () {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          var key = entry[0];\n          var value = entry[1];\n          if (predicate.call(context, value, key, collection)) {\n            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n          }\n        }\n      });\n    };\n    return filterSequence;\n  }\n\n  function countByFactory(collection, grouper, context) {\n    var groups = Map().asMutable();\n    collection.__iterate(function (v, k) {\n      groups.update(grouper.call(context, v, k, collection), 0, function (a) { return a + 1; });\n    });\n    return groups.asImmutable();\n  }\n\n  function groupByFactory(collection, grouper, context) {\n    var isKeyedIter = isKeyed(collection);\n    var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();\n    collection.__iterate(function (v, k) {\n      groups.update(\n        grouper.call(context, v, k, collection),\n        function (a) { return ((a = a || []), a.push(isKeyedIter ? [k, v] : v), a); }\n      );\n    });\n    var coerce = collectionClass(collection);\n    return groups.map(function (arr) { return reify(collection, coerce(arr)); }).asImmutable();\n  }\n\n  function sliceFactory(collection, begin, end, useKeys) {\n    var originalSize = collection.size;\n\n    if (wholeSlice(begin, end, originalSize)) {\n      return collection;\n    }\n\n    var resolvedBegin = resolveBegin(begin, originalSize);\n    var resolvedEnd = resolveEnd(end, originalSize);\n\n    // begin or end will be NaN if they were provided as negative numbers and\n    // this collection's size is unknown. In that case, cache first so there is\n    // a known size and these do not resolve to NaN.\n    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n      return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);\n    }\n\n    // Note: resolvedEnd is undefined when the original sequence's length is\n    // unknown and this slice did not supply an end and should contain all\n    // elements after resolvedBegin.\n    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n    var resolvedSize = resolvedEnd - resolvedBegin;\n    var sliceSize;\n    if (resolvedSize === resolvedSize) {\n      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n    }\n\n    var sliceSeq = makeSequence(collection);\n\n    // If collection.size is undefined, the size of the realized sliceSeq is\n    // unknown at this point unless the number of items to slice is 0\n    sliceSeq.size =\n      sliceSize === 0 ? sliceSize : (collection.size && sliceSize) || undefined;\n\n    if (!useKeys && isSeq(collection) && sliceSize >= 0) {\n      sliceSeq.get = function(index, notSetValue) {\n        index = wrapIndex(this, index);\n        return index >= 0 && index < sliceSize\n          ? collection.get(index + resolvedBegin, notSetValue)\n          : notSetValue;\n      };\n    }\n\n    sliceSeq.__iterateUncached = function(fn, reverse) {\n      var this$1 = this;\n\n      if (sliceSize === 0) {\n        return 0;\n      }\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var skipped = 0;\n      var isSkipping = true;\n      var iterations = 0;\n      collection.__iterate(function (v, k) {\n        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n          iterations++;\n          return (\n            fn(v, useKeys ? k : iterations - 1, this$1) !== false &&\n            iterations !== sliceSize\n          );\n        }\n      });\n      return iterations;\n    };\n\n    sliceSeq.__iteratorUncached = function(type, reverse) {\n      if (sliceSize !== 0 && reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      // Don't bother instantiating parent iterator if taking 0.\n      if (sliceSize === 0) {\n        return new Iterator(iteratorDone);\n      }\n      var iterator = collection.__iterator(type, reverse);\n      var skipped = 0;\n      var iterations = 0;\n      return new Iterator(function () {\n        while (skipped++ < resolvedBegin) {\n          iterator.next();\n        }\n        if (++iterations > sliceSize) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (useKeys || type === ITERATE_VALUES || step.done) {\n          return step;\n        }\n        if (type === ITERATE_KEYS) {\n          return iteratorValue(type, iterations - 1, undefined, step);\n        }\n        return iteratorValue(type, iterations - 1, step.value[1], step);\n      });\n    };\n\n    return sliceSeq;\n  }\n\n  function takeWhileFactory(collection, predicate, context) {\n    var takeSequence = makeSequence(collection);\n    takeSequence.__iterateUncached = function(fn, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      collection.__iterate(\n        function (v, k, c) { return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1); }\n      );\n      return iterations;\n    };\n    takeSequence.__iteratorUncached = function(type, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n      var iterating = true;\n      return new Iterator(function () {\n        if (!iterating) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var k = entry[0];\n        var v = entry[1];\n        if (!predicate.call(context, v, k, this$1)) {\n          iterating = false;\n          return iteratorDone();\n        }\n        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n      });\n    };\n    return takeSequence;\n  }\n\n  function skipWhileFactory(collection, predicate, context, useKeys) {\n    var skipSequence = makeSequence(collection);\n    skipSequence.__iterateUncached = function(fn, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var isSkipping = true;\n      var iterations = 0;\n      collection.__iterate(function (v, k, c) {\n        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$1);\n        }\n      });\n      return iterations;\n    };\n    skipSequence.__iteratorUncached = function(type, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n      var skipping = true;\n      var iterations = 0;\n      return new Iterator(function () {\n        var step;\n        var k;\n        var v;\n        do {\n          step = iterator.next();\n          if (step.done) {\n            if (useKeys || type === ITERATE_VALUES) {\n              return step;\n            }\n            if (type === ITERATE_KEYS) {\n              return iteratorValue(type, iterations++, undefined, step);\n            }\n            return iteratorValue(type, iterations++, step.value[1], step);\n          }\n          var entry = step.value;\n          k = entry[0];\n          v = entry[1];\n          skipping && (skipping = predicate.call(context, v, k, this$1));\n        } while (skipping);\n        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n      });\n    };\n    return skipSequence;\n  }\n\n  function concatFactory(collection, values) {\n    var isKeyedCollection = isKeyed(collection);\n    var iters = [collection]\n      .concat(values)\n      .map(function (v) {\n        if (!isCollection(v)) {\n          v = isKeyedCollection\n            ? keyedSeqFromValue(v)\n            : indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n        } else if (isKeyedCollection) {\n          v = KeyedCollection(v);\n        }\n        return v;\n      })\n      .filter(function (v) { return v.size !== 0; });\n\n    if (iters.length === 0) {\n      return collection;\n    }\n\n    if (iters.length === 1) {\n      var singleton = iters[0];\n      if (\n        singleton === collection ||\n        (isKeyedCollection && isKeyed(singleton)) ||\n        (isIndexed(collection) && isIndexed(singleton))\n      ) {\n        return singleton;\n      }\n    }\n\n    var concatSeq = new ArraySeq(iters);\n    if (isKeyedCollection) {\n      concatSeq = concatSeq.toKeyedSeq();\n    } else if (!isIndexed(collection)) {\n      concatSeq = concatSeq.toSetSeq();\n    }\n    concatSeq = concatSeq.flatten(true);\n    concatSeq.size = iters.reduce(function (sum, seq) {\n      if (sum !== undefined) {\n        var size = seq.size;\n        if (size !== undefined) {\n          return sum + size;\n        }\n      }\n    }, 0);\n    return concatSeq;\n  }\n\n  function flattenFactory(collection, depth, useKeys) {\n    var flatSequence = makeSequence(collection);\n    flatSequence.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      var stopped = false;\n      function flatDeep(iter, currentDepth) {\n        iter.__iterate(function (v, k) {\n          if ((!depth || currentDepth < depth) && isCollection(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else {\n            iterations++;\n            if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {\n              stopped = true;\n            }\n          }\n          return !stopped;\n        }, reverse);\n      }\n      flatDeep(collection, 0);\n      return iterations;\n    };\n    flatSequence.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = collection.__iterator(type, reverse);\n      var stack = [];\n      var iterations = 0;\n      return new Iterator(function () {\n        while (iterator) {\n          var step = iterator.next();\n          if (step.done !== false) {\n            iterator = stack.pop();\n            continue;\n          }\n          var v = step.value;\n          if (type === ITERATE_ENTRIES) {\n            v = v[1];\n          }\n          if ((!depth || stack.length < depth) && isCollection(v)) {\n            stack.push(iterator);\n            iterator = v.__iterator(type, reverse);\n          } else {\n            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n          }\n        }\n        return iteratorDone();\n      });\n    };\n    return flatSequence;\n  }\n\n  function flatMapFactory(collection, mapper, context) {\n    var coerce = collectionClass(collection);\n    return collection\n      .toSeq()\n      .map(function (v, k) { return coerce(mapper.call(context, v, k, collection)); })\n      .flatten(true);\n  }\n\n  function interposeFactory(collection, separator) {\n    var interposedSequence = makeSequence(collection);\n    interposedSequence.size = collection.size && collection.size * 2 - 1;\n    interposedSequence.__iterateUncached = function(fn, reverse) {\n      var this$1 = this;\n\n      var iterations = 0;\n      collection.__iterate(\n        function (v) { return (!iterations || fn(separator, iterations++, this$1) !== false) &&\n          fn(v, iterations++, this$1) !== false; },\n        reverse\n      );\n      return iterations;\n    };\n    interposedSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = collection.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      var step;\n      return new Iterator(function () {\n        if (!step || iterations % 2) {\n          step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n        }\n        return iterations % 2\n          ? iteratorValue(type, iterations++, separator)\n          : iteratorValue(type, iterations++, step.value, step);\n      });\n    };\n    return interposedSequence;\n  }\n\n  function sortFactory(collection, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    var isKeyedCollection = isKeyed(collection);\n    var index = 0;\n    var entries = collection\n      .toSeq()\n      .map(function (v, k) { return [k, v, index++, mapper ? mapper(v, k, collection) : v]; })\n      .valueSeq()\n      .toArray();\n    entries.sort(function (a, b) { return comparator(a[3], b[3]) || a[2] - b[2]; }).forEach(\n      isKeyedCollection\n        ? function (v, i) {\n            entries[i].length = 2;\n          }\n        : function (v, i) {\n            entries[i] = v[1];\n          }\n    );\n    return isKeyedCollection\n      ? KeyedSeq(entries)\n      : isIndexed(collection)\n        ? IndexedSeq(entries)\n        : SetSeq(entries);\n  }\n\n  function maxFactory(collection, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    if (mapper) {\n      var entry = collection\n        .toSeq()\n        .map(function (v, k) { return [v, mapper(v, k, collection)]; })\n        .reduce(function (a, b) { return (maxCompare(comparator, a[1], b[1]) ? b : a); });\n      return entry && entry[0];\n    }\n    return collection.reduce(function (a, b) { return (maxCompare(comparator, a, b) ? b : a); });\n  }\n\n  function maxCompare(comparator, a, b) {\n    var comp = comparator(b, a);\n    // b is considered the new max if the comparator declares them equal, but\n    // they are not equal and b is in fact a nullish value.\n    return (\n      (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) ||\n      comp > 0\n    );\n  }\n\n  function zipWithFactory(keyIter, zipper, iters, zipAll) {\n    var zipSequence = makeSequence(keyIter);\n    var sizes = new ArraySeq(iters).map(function (i) { return i.size; });\n    zipSequence.size = zipAll ? sizes.max() : sizes.min();\n    // Note: this a generic base implementation of __iterate in terms of\n    // __iterator which may be more generically useful in the future.\n    zipSequence.__iterate = function(fn, reverse) {\n      /* generic:\n      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        iterations++;\n        if (fn(step.value[1], step.value[0], this) === false) {\n          break;\n        }\n      }\n      return iterations;\n      */\n      // indexed:\n      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n    zipSequence.__iteratorUncached = function(type, reverse) {\n      var iterators = iters.map(\n        function (i) { return ((i = Collection(i)), getIterator(reverse ? i.reverse() : i)); }\n      );\n      var iterations = 0;\n      var isDone = false;\n      return new Iterator(function () {\n        var steps;\n        if (!isDone) {\n          steps = iterators.map(function (i) { return i.next(); });\n          isDone = zipAll ? steps.every(function (s) { return s.done; }) : steps.some(function (s) { return s.done; });\n        }\n        if (isDone) {\n          return iteratorDone();\n        }\n        return iteratorValue(\n          type,\n          iterations++,\n          zipper.apply(null, steps.map(function (s) { return s.value; }))\n        );\n      });\n    };\n    return zipSequence;\n  }\n\n  // #pragma Helper Functions\n\n  function reify(iter, seq) {\n    return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);\n  }\n\n  function validateEntry(entry) {\n    if (entry !== Object(entry)) {\n      throw new TypeError('Expected [K, V] tuple: ' + entry);\n    }\n  }\n\n  function collectionClass(collection) {\n    return isKeyed(collection)\n      ? KeyedCollection\n      : isIndexed(collection)\n        ? IndexedCollection\n        : SetCollection;\n  }\n\n  function makeSequence(collection) {\n    return Object.create(\n      (isKeyed(collection)\n        ? KeyedSeq\n        : isIndexed(collection)\n          ? IndexedSeq\n          : SetSeq\n      ).prototype\n    );\n  }\n\n  function cacheResultThrough() {\n    if (this._iter.cacheResult) {\n      this._iter.cacheResult();\n      this.size = this._iter.size;\n      return this;\n    }\n    return Seq.prototype.cacheResult.call(this);\n  }\n\n  function defaultComparator(a, b) {\n    if (a === undefined && b === undefined) {\n      return 0;\n    }\n\n    if (a === undefined) {\n      return 1;\n    }\n\n    if (b === undefined) {\n      return -1;\n    }\n\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  // http://jsperf.com/copy-array-inline\n  function arrCopy(arr, offset) {\n    offset = offset || 0;\n    var len = Math.max(0, arr.length - offset);\n    var newArr = new Array(len);\n    for (var ii = 0; ii < len; ii++) {\n      newArr[ii] = arr[ii + offset];\n    }\n    return newArr;\n  }\n\n  function invariant(condition, error) {\n    if (!condition) { throw new Error(error); }\n  }\n\n  function assertNotInfinite(size) {\n    invariant(\n      size !== Infinity,\n      'Cannot perform this action with an infinite size.'\n    );\n  }\n\n  function coerceKeyPath(keyPath) {\n    if (isArrayLike(keyPath) && typeof keyPath !== 'string') {\n      return keyPath;\n    }\n    if (isOrdered(keyPath)) {\n      return keyPath.toArray();\n    }\n    throw new TypeError(\n      'Invalid keyPath: expected Ordered Collection or Array: ' + keyPath\n    );\n  }\n\n  function isPlainObj(value) {\n    return (\n      value &&\n      (typeof value.constructor !== 'function' ||\n        value.constructor.name === 'Object')\n    );\n  }\n\n  /**\n   * Returns true if the value is a potentially-persistent data structure, either\n   * provided by Immutable.js or a plain Array or Object.\n   */\n  function isDataStructure(value) {\n    return (\n      typeof value === 'object' &&\n      (isImmutable(value) || Array.isArray(value) || isPlainObj(value))\n    );\n  }\n\n  /**\n   * Converts a value to a string, adding quotes if a string was provided.\n   */\n  function quoteString(value) {\n    try {\n      return typeof value === 'string' ? JSON.stringify(value) : String(value);\n    } catch (_ignoreError) {\n      return JSON.stringify(value);\n    }\n  }\n\n  function has(collection, key) {\n    return isImmutable(collection)\n      ? collection.has(key)\n      : isDataStructure(collection) && hasOwnProperty.call(collection, key);\n  }\n\n  function get(collection, key, notSetValue) {\n    return isImmutable(collection)\n      ? collection.get(key, notSetValue)\n      : !has(collection, key)\n        ? notSetValue\n        : typeof collection.get === 'function'\n          ? collection.get(key)\n          : collection[key];\n  }\n\n  function shallowCopy(from) {\n    if (Array.isArray(from)) {\n      return arrCopy(from);\n    }\n    var to = {};\n    for (var key in from) {\n      if (hasOwnProperty.call(from, key)) {\n        to[key] = from[key];\n      }\n    }\n    return to;\n  }\n\n  function remove(collection, key) {\n    if (!isDataStructure(collection)) {\n      throw new TypeError(\n        'Cannot update non-data-structure value: ' + collection\n      );\n    }\n    if (isImmutable(collection)) {\n      if (!collection.remove) {\n        throw new TypeError(\n          'Cannot update immutable value without .remove() method: ' + collection\n        );\n      }\n      return collection.remove(key);\n    }\n    if (!hasOwnProperty.call(collection, key)) {\n      return collection;\n    }\n    var collectionCopy = shallowCopy(collection);\n    if (Array.isArray(collectionCopy)) {\n      collectionCopy.splice(key, 1);\n    } else {\n      delete collectionCopy[key];\n    }\n    return collectionCopy;\n  }\n\n  function set(collection, key, value) {\n    if (!isDataStructure(collection)) {\n      throw new TypeError(\n        'Cannot update non-data-structure value: ' + collection\n      );\n    }\n    if (isImmutable(collection)) {\n      if (!collection.set) {\n        throw new TypeError(\n          'Cannot update immutable value without .set() method: ' + collection\n        );\n      }\n      return collection.set(key, value);\n    }\n    if (hasOwnProperty.call(collection, key) && value === collection[key]) {\n      return collection;\n    }\n    var collectionCopy = shallowCopy(collection);\n    collectionCopy[key] = value;\n    return collectionCopy;\n  }\n\n  function updateIn(collection, keyPath, notSetValue, updater) {\n    if (!updater) {\n      updater = notSetValue;\n      notSetValue = undefined;\n    }\n    var updatedValue = updateInDeeply(\n      isImmutable(collection),\n      collection,\n      coerceKeyPath(keyPath),\n      0,\n      notSetValue,\n      updater\n    );\n    return updatedValue === NOT_SET ? notSetValue : updatedValue;\n  }\n\n  function updateInDeeply(\n    inImmutable,\n    existing,\n    keyPath,\n    i,\n    notSetValue,\n    updater\n  ) {\n    var wasNotSet = existing === NOT_SET;\n    if (i === keyPath.length) {\n      var existingValue = wasNotSet ? notSetValue : existing;\n      var newValue = updater(existingValue);\n      return newValue === existingValue ? existing : newValue;\n    }\n    if (!wasNotSet && !isDataStructure(existing)) {\n      throw new TypeError(\n        'Cannot update within non-data-structure value in path [' +\n          keyPath.slice(0, i).map(quoteString) +\n          ']: ' +\n          existing\n      );\n    }\n    var key = keyPath[i];\n    var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);\n    var nextUpdated = updateInDeeply(\n      nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting),\n      nextExisting,\n      keyPath,\n      i + 1,\n      notSetValue,\n      updater\n    );\n    return nextUpdated === nextExisting\n      ? existing\n      : nextUpdated === NOT_SET\n        ? remove(existing, key)\n        : set(\n            wasNotSet ? (inImmutable ? emptyMap() : {}) : existing,\n            key,\n            nextUpdated\n          );\n  }\n\n  function setIn(collection, keyPath, value) {\n    return updateIn(collection, keyPath, NOT_SET, function () { return value; });\n  }\n\n  function setIn$1(keyPath, v) {\n    return setIn(this, keyPath, v);\n  }\n\n  function removeIn(collection, keyPath) {\n    return updateIn(collection, keyPath, function () { return NOT_SET; });\n  }\n\n  function deleteIn(keyPath) {\n    return removeIn(this, keyPath);\n  }\n\n  function update(collection, key, notSetValue, updater) {\n    return updateIn(collection, [key], notSetValue, updater);\n  }\n\n  function update$1(key, notSetValue, updater) {\n    return arguments.length === 1\n      ? key(this)\n      : update(this, key, notSetValue, updater);\n  }\n\n  function updateIn$1(keyPath, notSetValue, updater) {\n    return updateIn(this, keyPath, notSetValue, updater);\n  }\n\n  function merge() {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    return mergeIntoKeyedWith(this, iters);\n  }\n\n  function mergeWith(merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    if (typeof merger !== 'function') {\n      throw new TypeError('Invalid merger function: ' + merger);\n    }\n    return mergeIntoKeyedWith(this, iters, merger);\n  }\n\n  function mergeIntoKeyedWith(collection, collections, merger) {\n    var iters = [];\n    for (var ii = 0; ii < collections.length; ii++) {\n      var collection$1 = KeyedCollection(collections[ii]);\n      if (collection$1.size !== 0) {\n        iters.push(collection$1);\n      }\n    }\n    if (iters.length === 0) {\n      return collection;\n    }\n    if (\n      collection.toSeq().size === 0 &&\n      !collection.__ownerID &&\n      iters.length === 1\n    ) {\n      return collection.constructor(iters[0]);\n    }\n    return collection.withMutations(function (collection) {\n      var mergeIntoCollection = merger\n        ? function (value, key) {\n            update(\n              collection,\n              key,\n              NOT_SET,\n              function (oldVal) { return (oldVal === NOT_SET ? value : merger(oldVal, value, key)); }\n            );\n          }\n        : function (value, key) {\n            collection.set(key, value);\n          };\n      for (var ii = 0; ii < iters.length; ii++) {\n        iters[ii].forEach(mergeIntoCollection);\n      }\n    });\n  }\n\n  function merge$1(collection) {\n    var sources = [], len = arguments.length - 1;\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n    return mergeWithSources(collection, sources);\n  }\n\n  function mergeWith$1(merger, collection) {\n    var sources = [], len = arguments.length - 2;\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];\n\n    return mergeWithSources(collection, sources, merger);\n  }\n\n  function mergeDeep(collection) {\n    var sources = [], len = arguments.length - 1;\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n    return mergeDeepWithSources(collection, sources);\n  }\n\n  function mergeDeepWith(merger, collection) {\n    var sources = [], len = arguments.length - 2;\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];\n\n    return mergeDeepWithSources(collection, sources, merger);\n  }\n\n  function mergeDeepWithSources(collection, sources, merger) {\n    return mergeWithSources(collection, sources, deepMergerWith(merger));\n  }\n\n  function mergeWithSources(collection, sources, merger) {\n    if (!isDataStructure(collection)) {\n      throw new TypeError(\n        'Cannot merge into non-data-structure value: ' + collection\n      );\n    }\n    if (isImmutable(collection)) {\n      return typeof merger === 'function' && collection.mergeWith\n        ? collection.mergeWith.apply(collection, [ merger ].concat( sources ))\n        : collection.merge\n          ? collection.merge.apply(collection, sources)\n          : collection.concat.apply(collection, sources);\n    }\n    var isArray = Array.isArray(collection);\n    var merged = collection;\n    var Collection$$1 = isArray ? IndexedCollection : KeyedCollection;\n    var mergeItem = isArray\n      ? function (value) {\n          // Copy on write\n          if (merged === collection) {\n            merged = shallowCopy(merged);\n          }\n          merged.push(value);\n        }\n      : function (value, key) {\n          var hasVal = hasOwnProperty.call(merged, key);\n          var nextVal =\n            hasVal && merger ? merger(merged[key], value, key) : value;\n          if (!hasVal || nextVal !== merged[key]) {\n            // Copy on write\n            if (merged === collection) {\n              merged = shallowCopy(merged);\n            }\n            merged[key] = nextVal;\n          }\n        };\n    for (var i = 0; i < sources.length; i++) {\n      Collection$$1(sources[i]).forEach(mergeItem);\n    }\n    return merged;\n  }\n\n  function deepMergerWith(merger) {\n    function deepMerger(oldValue, newValue, key) {\n      return isDataStructure(oldValue) && isDataStructure(newValue)\n        ? mergeWithSources(oldValue, [newValue], deepMerger)\n        : merger\n          ? merger(oldValue, newValue, key)\n          : newValue;\n    }\n    return deepMerger;\n  }\n\n  function mergeDeep$1() {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    return mergeDeepWithSources(this, iters);\n  }\n\n  function mergeDeepWith$1(merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return mergeDeepWithSources(this, iters, merger);\n  }\n\n  function mergeIn(keyPath) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return updateIn(this, keyPath, emptyMap(), function (m) { return mergeWithSources(m, iters); });\n  }\n\n  function mergeDeepIn(keyPath) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return updateIn(this, keyPath, emptyMap(), function (m) { return mergeDeepWithSources(m, iters); }\n    );\n  }\n\n  function withMutations(fn) {\n    var mutable = this.asMutable();\n    fn(mutable);\n    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n  }\n\n  function asMutable() {\n    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n  }\n\n  function asImmutable() {\n    return this.__ensureOwner();\n  }\n\n  function wasAltered() {\n    return this.__altered;\n  }\n\n  var Map = /*@__PURE__*/(function (KeyedCollection$$1) {\n    function Map(value) {\n      return value === null || value === undefined\n        ? emptyMap()\n        : isMap(value) && !isOrdered(value)\n          ? value\n          : emptyMap().withMutations(function (map) {\n              var iter = KeyedCollection$$1(value);\n              assertNotInfinite(iter.size);\n              iter.forEach(function (v, k) { return map.set(k, v); });\n            });\n    }\n\n    if ( KeyedCollection$$1 ) Map.__proto__ = KeyedCollection$$1;\n    Map.prototype = Object.create( KeyedCollection$$1 && KeyedCollection$$1.prototype );\n    Map.prototype.constructor = Map;\n\n    Map.of = function of () {\n      var keyValues = [], len = arguments.length;\n      while ( len-- ) keyValues[ len ] = arguments[ len ];\n\n      return emptyMap().withMutations(function (map) {\n        for (var i = 0; i < keyValues.length; i += 2) {\n          if (i + 1 >= keyValues.length) {\n            throw new Error('Missing value for key: ' + keyValues[i]);\n          }\n          map.set(keyValues[i], keyValues[i + 1]);\n        }\n      });\n    };\n\n    Map.prototype.toString = function toString () {\n      return this.__toString('Map {', '}');\n    };\n\n    // @pragma Access\n\n    Map.prototype.get = function get (k, notSetValue) {\n      return this._root\n        ? this._root.get(0, undefined, k, notSetValue)\n        : notSetValue;\n    };\n\n    // @pragma Modification\n\n    Map.prototype.set = function set (k, v) {\n      return updateMap(this, k, v);\n    };\n\n    Map.prototype.remove = function remove (k) {\n      return updateMap(this, k, NOT_SET);\n    };\n\n    Map.prototype.deleteAll = function deleteAll (keys) {\n      var collection = Collection(keys);\n\n      if (collection.size === 0) {\n        return this;\n      }\n\n      return this.withMutations(function (map) {\n        collection.forEach(function (key) { return map.remove(key); });\n      });\n    };\n\n    Map.prototype.clear = function clear () {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._root = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyMap();\n    };\n\n    // @pragma Composition\n\n    Map.prototype.sort = function sort (comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator));\n    };\n\n    Map.prototype.sortBy = function sortBy (mapper, comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator, mapper));\n    };\n\n    Map.prototype.map = function map (mapper, context) {\n      return this.withMutations(function (map) {\n        map.forEach(function (value, key) {\n          map.set(key, mapper.call(context, value, key, map));\n        });\n      });\n    };\n\n    // @pragma Mutability\n\n    Map.prototype.__iterator = function __iterator (type, reverse) {\n      return new MapIterator(this, type, reverse);\n    };\n\n    Map.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      var iterations = 0;\n      this._root &&\n        this._root.iterate(function (entry) {\n          iterations++;\n          return fn(entry[1], entry[0], this$1);\n        }, reverse);\n      return iterations;\n    };\n\n    Map.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyMap();\n        }\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeMap(this.size, this._root, ownerID, this.__hash);\n    };\n\n    return Map;\n  }(KeyedCollection));\n\n  Map.isMap = isMap;\n\n  var MapPrototype = Map.prototype;\n  MapPrototype[IS_MAP_SYMBOL] = true;\n  MapPrototype[DELETE] = MapPrototype.remove;\n  MapPrototype.removeAll = MapPrototype.deleteAll;\n  MapPrototype.setIn = setIn$1;\n  MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;\n  MapPrototype.update = update$1;\n  MapPrototype.updateIn = updateIn$1;\n  MapPrototype.merge = MapPrototype.concat = merge;\n  MapPrototype.mergeWith = mergeWith;\n  MapPrototype.mergeDeep = mergeDeep$1;\n  MapPrototype.mergeDeepWith = mergeDeepWith$1;\n  MapPrototype.mergeIn = mergeIn;\n  MapPrototype.mergeDeepIn = mergeDeepIn;\n  MapPrototype.withMutations = withMutations;\n  MapPrototype.wasAltered = wasAltered;\n  MapPrototype.asImmutable = asImmutable;\n  MapPrototype['@@transducer/init'] = MapPrototype.asMutable = asMutable;\n  MapPrototype['@@transducer/step'] = function(result, arr) {\n    return result.set(arr[0], arr[1]);\n  };\n  MapPrototype['@@transducer/result'] = function(obj) {\n    return obj.asImmutable();\n  };\n\n  // #pragma Trie Nodes\n\n  var ArrayMapNode = function ArrayMapNode(ownerID, entries) {\n    this.ownerID = ownerID;\n    this.entries = entries;\n  };\n\n  ArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n    var entries = this.entries;\n    for (var ii = 0, len = entries.length; ii < len; ii++) {\n      if (is(key, entries[ii][0])) {\n        return entries[ii][1];\n      }\n    }\n    return notSetValue;\n  };\n\n  ArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    var removed = value === NOT_SET;\n\n    var entries = this.entries;\n    var idx = 0;\n    var len = entries.length;\n    for (; idx < len; idx++) {\n      if (is(key, entries[idx][0])) {\n        break;\n      }\n    }\n    var exists = idx < len;\n\n    if (exists ? entries[idx][1] === value : removed) {\n      return this;\n    }\n\n    SetRef(didAlter);\n    (removed || !exists) && SetRef(didChangeSize);\n\n    if (removed && entries.length === 1) {\n      return; // undefined\n    }\n\n    if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n      return createNodes(ownerID, entries, key, value);\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newEntries = isEditable ? entries : arrCopy(entries);\n\n    if (exists) {\n      if (removed) {\n        idx === len - 1\n          ? newEntries.pop()\n          : (newEntries[idx] = newEntries.pop());\n      } else {\n        newEntries[idx] = [key, value];\n      }\n    } else {\n      newEntries.push([key, value]);\n    }\n\n    if (isEditable) {\n      this.entries = newEntries;\n      return this;\n    }\n\n    return new ArrayMapNode(ownerID, newEntries);\n  };\n\n  var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {\n    this.ownerID = ownerID;\n    this.bitmap = bitmap;\n    this.nodes = nodes;\n  };\n\n  BitmapIndexedNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);\n    var bitmap = this.bitmap;\n    return (bitmap & bit) === 0\n      ? notSetValue\n      : this.nodes[popCount(bitmap & (bit - 1))].get(\n          shift + SHIFT,\n          keyHash,\n          key,\n          notSetValue\n        );\n  };\n\n  BitmapIndexedNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var bit = 1 << keyHashFrag;\n    var bitmap = this.bitmap;\n    var exists = (bitmap & bit) !== 0;\n\n    if (!exists && value === NOT_SET) {\n      return this;\n    }\n\n    var idx = popCount(bitmap & (bit - 1));\n    var nodes = this.nodes;\n    var node = exists ? nodes[idx] : undefined;\n    var newNode = updateNode(\n      node,\n      ownerID,\n      shift + SHIFT,\n      keyHash,\n      key,\n      value,\n      didChangeSize,\n      didAlter\n    );\n\n    if (newNode === node) {\n      return this;\n    }\n\n    if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n      return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n    }\n\n    if (\n      exists &&\n      !newNode &&\n      nodes.length === 2 &&\n      isLeafNode(nodes[idx ^ 1])\n    ) {\n      return nodes[idx ^ 1];\n    }\n\n    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n      return newNode;\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newBitmap = exists ? (newNode ? bitmap : bitmap ^ bit) : bitmap | bit;\n    var newNodes = exists\n      ? newNode\n        ? setAt(nodes, idx, newNode, isEditable)\n        : spliceOut(nodes, idx, isEditable)\n      : spliceIn(nodes, idx, newNode, isEditable);\n\n    if (isEditable) {\n      this.bitmap = newBitmap;\n      this.nodes = newNodes;\n      return this;\n    }\n\n    return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n  };\n\n  var HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {\n    this.ownerID = ownerID;\n    this.count = count;\n    this.nodes = nodes;\n  };\n\n  HashArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var node = this.nodes[idx];\n    return node\n      ? node.get(shift + SHIFT, keyHash, key, notSetValue)\n      : notSetValue;\n  };\n\n  HashArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var removed = value === NOT_SET;\n    var nodes = this.nodes;\n    var node = nodes[idx];\n\n    if (removed && !node) {\n      return this;\n    }\n\n    var newNode = updateNode(\n      node,\n      ownerID,\n      shift + SHIFT,\n      keyHash,\n      key,\n      value,\n      didChangeSize,\n      didAlter\n    );\n    if (newNode === node) {\n      return this;\n    }\n\n    var newCount = this.count;\n    if (!node) {\n      newCount++;\n    } else if (!newNode) {\n      newCount--;\n      if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n        return packNodes(ownerID, nodes, newCount, idx);\n      }\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newNodes = setAt(nodes, idx, newNode, isEditable);\n\n    if (isEditable) {\n      this.count = newCount;\n      this.nodes = newNodes;\n      return this;\n    }\n\n    return new HashArrayMapNode(ownerID, newCount, newNodes);\n  };\n\n  var HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {\n    this.ownerID = ownerID;\n    this.keyHash = keyHash;\n    this.entries = entries;\n  };\n\n  HashCollisionNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n    var entries = this.entries;\n    for (var ii = 0, len = entries.length; ii < len; ii++) {\n      if (is(key, entries[ii][0])) {\n        return entries[ii][1];\n      }\n    }\n    return notSetValue;\n  };\n\n  HashCollisionNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n\n    var removed = value === NOT_SET;\n\n    if (keyHash !== this.keyHash) {\n      if (removed) {\n        return this;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n    }\n\n    var entries = this.entries;\n    var idx = 0;\n    var len = entries.length;\n    for (; idx < len; idx++) {\n      if (is(key, entries[idx][0])) {\n        break;\n      }\n    }\n    var exists = idx < len;\n\n    if (exists ? entries[idx][1] === value : removed) {\n      return this;\n    }\n\n    SetRef(didAlter);\n    (removed || !exists) && SetRef(didChangeSize);\n\n    if (removed && len === 2) {\n      return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newEntries = isEditable ? entries : arrCopy(entries);\n\n    if (exists) {\n      if (removed) {\n        idx === len - 1\n          ? newEntries.pop()\n          : (newEntries[idx] = newEntries.pop());\n      } else {\n        newEntries[idx] = [key, value];\n      }\n    } else {\n      newEntries.push([key, value]);\n    }\n\n    if (isEditable) {\n      this.entries = newEntries;\n      return this;\n    }\n\n    return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n  };\n\n  var ValueNode = function ValueNode(ownerID, keyHash, entry) {\n    this.ownerID = ownerID;\n    this.keyHash = keyHash;\n    this.entry = entry;\n  };\n\n  ValueNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n    return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n  };\n\n  ValueNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    var removed = value === NOT_SET;\n    var keyMatch = is(key, this.entry[0]);\n    if (keyMatch ? value === this.entry[1] : removed) {\n      return this;\n    }\n\n    SetRef(didAlter);\n\n    if (removed) {\n      SetRef(didChangeSize);\n      return; // undefined\n    }\n\n    if (keyMatch) {\n      if (ownerID && ownerID === this.ownerID) {\n        this.entry[1] = value;\n        return this;\n      }\n      return new ValueNode(ownerID, this.keyHash, [key, value]);\n    }\n\n    SetRef(didChangeSize);\n    return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n  };\n\n  // #pragma Iterators\n\n  ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(\n    fn,\n    reverse\n  ) {\n    var entries = this.entries;\n    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n        return false;\n      }\n    }\n  };\n\n  BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(\n    fn,\n    reverse\n  ) {\n    var nodes = this.nodes;\n    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n      var node = nodes[reverse ? maxIndex - ii : ii];\n      if (node && node.iterate(fn, reverse) === false) {\n        return false;\n      }\n    }\n  };\n\n  // eslint-disable-next-line no-unused-vars\n  ValueNode.prototype.iterate = function(fn, reverse) {\n    return fn(this.entry);\n  };\n\n  var MapIterator = /*@__PURE__*/(function (Iterator$$1) {\n    function MapIterator(map, type, reverse) {\n      this._type = type;\n      this._reverse = reverse;\n      this._stack = map._root && mapIteratorFrame(map._root);\n    }\n\n    if ( Iterator$$1 ) MapIterator.__proto__ = Iterator$$1;\n    MapIterator.prototype = Object.create( Iterator$$1 && Iterator$$1.prototype );\n    MapIterator.prototype.constructor = MapIterator;\n\n    MapIterator.prototype.next = function next () {\n      var type = this._type;\n      var stack = this._stack;\n      while (stack) {\n        var node = stack.node;\n        var index = stack.index++;\n        var maxIndex = (void 0);\n        if (node.entry) {\n          if (index === 0) {\n            return mapIteratorValue(type, node.entry);\n          }\n        } else if (node.entries) {\n          maxIndex = node.entries.length - 1;\n          if (index <= maxIndex) {\n            return mapIteratorValue(\n              type,\n              node.entries[this._reverse ? maxIndex - index : index]\n            );\n          }\n        } else {\n          maxIndex = node.nodes.length - 1;\n          if (index <= maxIndex) {\n            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n            if (subNode) {\n              if (subNode.entry) {\n                return mapIteratorValue(type, subNode.entry);\n              }\n              stack = this._stack = mapIteratorFrame(subNode, stack);\n            }\n            continue;\n          }\n        }\n        stack = this._stack = this._stack.__prev;\n      }\n      return iteratorDone();\n    };\n\n    return MapIterator;\n  }(Iterator));\n\n  function mapIteratorValue(type, entry) {\n    return iteratorValue(type, entry[0], entry[1]);\n  }\n\n  function mapIteratorFrame(node, prev) {\n    return {\n      node: node,\n      index: 0,\n      __prev: prev,\n    };\n  }\n\n  function makeMap(size, root, ownerID, hash$$1) {\n    var map = Object.create(MapPrototype);\n    map.size = size;\n    map._root = root;\n    map.__ownerID = ownerID;\n    map.__hash = hash$$1;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_MAP;\n  function emptyMap() {\n    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n  }\n\n  function updateMap(map, k, v) {\n    var newRoot;\n    var newSize;\n    if (!map._root) {\n      if (v === NOT_SET) {\n        return map;\n      }\n      newSize = 1;\n      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n    } else {\n      var didChangeSize = MakeRef();\n      var didAlter = MakeRef();\n      newRoot = updateNode(\n        map._root,\n        map.__ownerID,\n        0,\n        undefined,\n        k,\n        v,\n        didChangeSize,\n        didAlter\n      );\n      if (!didAlter.value) {\n        return map;\n      }\n      newSize = map.size + (didChangeSize.value ? (v === NOT_SET ? -1 : 1) : 0);\n    }\n    if (map.__ownerID) {\n      map.size = newSize;\n      map._root = newRoot;\n      map.__hash = undefined;\n      map.__altered = true;\n      return map;\n    }\n    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n  }\n\n  function updateNode(\n    node,\n    ownerID,\n    shift,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  ) {\n    if (!node) {\n      if (value === NOT_SET) {\n        return node;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return new ValueNode(ownerID, keyHash, [key, value]);\n    }\n    return node.update(\n      ownerID,\n      shift,\n      keyHash,\n      key,\n      value,\n      didChangeSize,\n      didAlter\n    );\n  }\n\n  function isLeafNode(node) {\n    return (\n      node.constructor === ValueNode || node.constructor === HashCollisionNode\n    );\n  }\n\n  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n    if (node.keyHash === keyHash) {\n      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n    }\n\n    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n    var newNode;\n    var nodes =\n      idx1 === idx2\n        ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)]\n        : ((newNode = new ValueNode(ownerID, keyHash, entry)),\n          idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n  }\n\n  function createNodes(ownerID, entries, key, value) {\n    if (!ownerID) {\n      ownerID = new OwnerID();\n    }\n    var node = new ValueNode(ownerID, hash(key), [key, value]);\n    for (var ii = 0; ii < entries.length; ii++) {\n      var entry = entries[ii];\n      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n    }\n    return node;\n  }\n\n  function packNodes(ownerID, nodes, count, excluding) {\n    var bitmap = 0;\n    var packedII = 0;\n    var packedNodes = new Array(count);\n    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n      var node = nodes[ii];\n      if (node !== undefined && ii !== excluding) {\n        bitmap |= bit;\n        packedNodes[packedII++] = node;\n      }\n    }\n    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n  }\n\n  function expandNodes(ownerID, nodes, bitmap, including, node) {\n    var count = 0;\n    var expandedNodes = new Array(SIZE);\n    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n    }\n    expandedNodes[including] = node;\n    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n  }\n\n  function popCount(x) {\n    x -= (x >> 1) & 0x55555555;\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0f0f0f0f;\n    x += x >> 8;\n    x += x >> 16;\n    return x & 0x7f;\n  }\n\n  function setAt(array, idx, val, canEdit) {\n    var newArray = canEdit ? array : arrCopy(array);\n    newArray[idx] = val;\n    return newArray;\n  }\n\n  function spliceIn(array, idx, val, canEdit) {\n    var newLen = array.length + 1;\n    if (canEdit && idx + 1 === newLen) {\n      array[idx] = val;\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        newArray[ii] = val;\n        after = -1;\n      } else {\n        newArray[ii] = array[ii + after];\n      }\n    }\n    return newArray;\n  }\n\n  function spliceOut(array, idx, canEdit) {\n    var newLen = array.length - 1;\n    if (canEdit && idx === newLen) {\n      array.pop();\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        after = 1;\n      }\n      newArray[ii] = array[ii + after];\n    }\n    return newArray;\n  }\n\n  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\n  var IS_LIST_SYMBOL = '@@__IMMUTABLE_LIST__@@';\n\n  function isList(maybeList) {\n    return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);\n  }\n\n  var List = /*@__PURE__*/(function (IndexedCollection$$1) {\n    function List(value) {\n      var empty = emptyList();\n      if (value === null || value === undefined) {\n        return empty;\n      }\n      if (isList(value)) {\n        return value;\n      }\n      var iter = IndexedCollection$$1(value);\n      var size = iter.size;\n      if (size === 0) {\n        return empty;\n      }\n      assertNotInfinite(size);\n      if (size > 0 && size < SIZE) {\n        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n      }\n      return empty.withMutations(function (list) {\n        list.setSize(size);\n        iter.forEach(function (v, i) { return list.set(i, v); });\n      });\n    }\n\n    if ( IndexedCollection$$1 ) List.__proto__ = IndexedCollection$$1;\n    List.prototype = Object.create( IndexedCollection$$1 && IndexedCollection$$1.prototype );\n    List.prototype.constructor = List;\n\n    List.of = function of (/*...values*/) {\n      return this(arguments);\n    };\n\n    List.prototype.toString = function toString () {\n      return this.__toString('List [', ']');\n    };\n\n    // @pragma Access\n\n    List.prototype.get = function get (index, notSetValue) {\n      index = wrapIndex(this, index);\n      if (index >= 0 && index < this.size) {\n        index += this._origin;\n        var node = listNodeFor(this, index);\n        return node && node.array[index & MASK];\n      }\n      return notSetValue;\n    };\n\n    // @pragma Modification\n\n    List.prototype.set = function set (index, value) {\n      return updateList(this, index, value);\n    };\n\n    List.prototype.remove = function remove (index) {\n      return !this.has(index)\n        ? this\n        : index === 0\n          ? this.shift()\n          : index === this.size - 1\n            ? this.pop()\n            : this.splice(index, 1);\n    };\n\n    List.prototype.insert = function insert (index, value) {\n      return this.splice(index, 0, value);\n    };\n\n    List.prototype.clear = function clear () {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = this._origin = this._capacity = 0;\n        this._level = SHIFT;\n        this._root = this._tail = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyList();\n    };\n\n    List.prototype.push = function push (/*...values*/) {\n      var values = arguments;\n      var oldSize = this.size;\n      return this.withMutations(function (list) {\n        setListBounds(list, 0, oldSize + values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(oldSize + ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.pop = function pop () {\n      return setListBounds(this, 0, -1);\n    };\n\n    List.prototype.unshift = function unshift (/*...values*/) {\n      var values = arguments;\n      return this.withMutations(function (list) {\n        setListBounds(list, -values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.shift = function shift () {\n      return setListBounds(this, 1);\n    };\n\n    // @pragma Composition\n\n    List.prototype.concat = function concat (/*...collections*/) {\n      var arguments$1 = arguments;\n\n      var seqs = [];\n      for (var i = 0; i < arguments.length; i++) {\n        var argument = arguments$1[i];\n        var seq = IndexedCollection$$1(\n          typeof argument !== 'string' && hasIterator(argument)\n            ? argument\n            : [argument]\n        );\n        if (seq.size !== 0) {\n          seqs.push(seq);\n        }\n      }\n      if (seqs.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && !this.__ownerID && seqs.length === 1) {\n        return this.constructor(seqs[0]);\n      }\n      return this.withMutations(function (list) {\n        seqs.forEach(function (seq) { return seq.forEach(function (value) { return list.push(value); }); });\n      });\n    };\n\n    List.prototype.setSize = function setSize (size) {\n      return setListBounds(this, 0, size);\n    };\n\n    List.prototype.map = function map (mapper, context) {\n      var this$1 = this;\n\n      return this.withMutations(function (list) {\n        for (var i = 0; i < this$1.size; i++) {\n          list.set(i, mapper.call(context, list.get(i), i, list));\n        }\n      });\n    };\n\n    // @pragma Iteration\n\n    List.prototype.slice = function slice (begin, end) {\n      var size = this.size;\n      if (wholeSlice(begin, end, size)) {\n        return this;\n      }\n      return setListBounds(\n        this,\n        resolveBegin(begin, size),\n        resolveEnd(end, size)\n      );\n    };\n\n    List.prototype.__iterator = function __iterator (type, reverse) {\n      var index = reverse ? this.size : 0;\n      var values = iterateList(this, reverse);\n      return new Iterator(function () {\n        var value = values();\n        return value === DONE\n          ? iteratorDone()\n          : iteratorValue(type, reverse ? --index : index++, value);\n      });\n    };\n\n    List.prototype.__iterate = function __iterate (fn, reverse) {\n      var index = reverse ? this.size : 0;\n      var values = iterateList(this, reverse);\n      var value;\n      while ((value = values()) !== DONE) {\n        if (fn(value, reverse ? --index : index++, this) === false) {\n          break;\n        }\n      }\n      return index;\n    };\n\n    List.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyList();\n        }\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeList(\n        this._origin,\n        this._capacity,\n        this._level,\n        this._root,\n        this._tail,\n        ownerID,\n        this.__hash\n      );\n    };\n\n    return List;\n  }(IndexedCollection));\n\n  List.isList = isList;\n\n  var ListPrototype = List.prototype;\n  ListPrototype[IS_LIST_SYMBOL] = true;\n  ListPrototype[DELETE] = ListPrototype.remove;\n  ListPrototype.merge = ListPrototype.concat;\n  ListPrototype.setIn = setIn$1;\n  ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;\n  ListPrototype.update = update$1;\n  ListPrototype.updateIn = updateIn$1;\n  ListPrototype.mergeIn = mergeIn;\n  ListPrototype.mergeDeepIn = mergeDeepIn;\n  ListPrototype.withMutations = withMutations;\n  ListPrototype.wasAltered = wasAltered;\n  ListPrototype.asImmutable = asImmutable;\n  ListPrototype['@@transducer/init'] = ListPrototype.asMutable = asMutable;\n  ListPrototype['@@transducer/step'] = function(result, arr) {\n    return result.push(arr);\n  };\n  ListPrototype['@@transducer/result'] = function(obj) {\n    return obj.asImmutable();\n  };\n\n  var VNode = function VNode(array, ownerID) {\n    this.array = array;\n    this.ownerID = ownerID;\n  };\n\n  // TODO: seems like these methods are very similar\n\n  VNode.prototype.removeBefore = function removeBefore (ownerID, level, index) {\n    if (index === level ? 1 << level : this.array.length === 0) {\n      return this;\n    }\n    var originIndex = (index >>> level) & MASK;\n    if (originIndex >= this.array.length) {\n      return new VNode([], ownerID);\n    }\n    var removingFirst = originIndex === 0;\n    var newChild;\n    if (level > 0) {\n      var oldChild = this.array[originIndex];\n      newChild =\n        oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n      if (newChild === oldChild && removingFirst) {\n        return this;\n      }\n    }\n    if (removingFirst && !newChild) {\n      return this;\n    }\n    var editable = editableVNode(this, ownerID);\n    if (!removingFirst) {\n      for (var ii = 0; ii < originIndex; ii++) {\n        editable.array[ii] = undefined;\n      }\n    }\n    if (newChild) {\n      editable.array[originIndex] = newChild;\n    }\n    return editable;\n  };\n\n  VNode.prototype.removeAfter = function removeAfter (ownerID, level, index) {\n    if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n      return this;\n    }\n    var sizeIndex = ((index - 1) >>> level) & MASK;\n    if (sizeIndex >= this.array.length) {\n      return this;\n    }\n\n    var newChild;\n    if (level > 0) {\n      var oldChild = this.array[sizeIndex];\n      newChild =\n        oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n      if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n        return this;\n      }\n    }\n\n    var editable = editableVNode(this, ownerID);\n    editable.array.splice(sizeIndex + 1);\n    if (newChild) {\n      editable.array[sizeIndex] = newChild;\n    }\n    return editable;\n  };\n\n  var DONE = {};\n\n  function iterateList(list, reverse) {\n    var left = list._origin;\n    var right = list._capacity;\n    var tailPos = getTailOffset(right);\n    var tail = list._tail;\n\n    return iterateNodeOrLeaf(list._root, list._level, 0);\n\n    function iterateNodeOrLeaf(node, level, offset) {\n      return level === 0\n        ? iterateLeaf(node, offset)\n        : iterateNode(node, level, offset);\n    }\n\n    function iterateLeaf(node, offset) {\n      var array = offset === tailPos ? tail && tail.array : node && node.array;\n      var from = offset > left ? 0 : left - offset;\n      var to = right - offset;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function () {\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        return array && array[idx];\n      };\n    }\n\n    function iterateNode(node, level, offset) {\n      var values;\n      var array = node && node.array;\n      var from = offset > left ? 0 : (left - offset) >> level;\n      var to = ((right - offset) >> level) + 1;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function () {\n        while (true) {\n          if (values) {\n            var value = values();\n            if (value !== DONE) {\n              return value;\n            }\n            values = null;\n          }\n          if (from === to) {\n            return DONE;\n          }\n          var idx = reverse ? --to : from++;\n          values = iterateNodeOrLeaf(\n            array && array[idx],\n            level - SHIFT,\n            offset + (idx << level)\n          );\n        }\n      };\n    }\n  }\n\n  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n    var list = Object.create(ListPrototype);\n    list.size = capacity - origin;\n    list._origin = origin;\n    list._capacity = capacity;\n    list._level = level;\n    list._root = root;\n    list._tail = tail;\n    list.__ownerID = ownerID;\n    list.__hash = hash;\n    list.__altered = false;\n    return list;\n  }\n\n  var EMPTY_LIST;\n  function emptyList() {\n    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n  }\n\n  function updateList(list, index, value) {\n    index = wrapIndex(list, index);\n\n    if (index !== index) {\n      return list;\n    }\n\n    if (index >= list.size || index < 0) {\n      return list.withMutations(function (list) {\n        index < 0\n          ? setListBounds(list, index).set(0, value)\n          : setListBounds(list, 0, index + 1).set(index, value);\n      });\n    }\n\n    index += list._origin;\n\n    var newTail = list._tail;\n    var newRoot = list._root;\n    var didAlter = MakeRef();\n    if (index >= getTailOffset(list._capacity)) {\n      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n    } else {\n      newRoot = updateVNode(\n        newRoot,\n        list.__ownerID,\n        list._level,\n        index,\n        value,\n        didAlter\n      );\n    }\n\n    if (!didAlter.value) {\n      return list;\n    }\n\n    if (list.__ownerID) {\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n  }\n\n  function updateVNode(node, ownerID, level, index, value, didAlter) {\n    var idx = (index >>> level) & MASK;\n    var nodeHas = node && idx < node.array.length;\n    if (!nodeHas && value === undefined) {\n      return node;\n    }\n\n    var newNode;\n\n    if (level > 0) {\n      var lowerNode = node && node.array[idx];\n      var newLowerNode = updateVNode(\n        lowerNode,\n        ownerID,\n        level - SHIFT,\n        index,\n        value,\n        didAlter\n      );\n      if (newLowerNode === lowerNode) {\n        return node;\n      }\n      newNode = editableVNode(node, ownerID);\n      newNode.array[idx] = newLowerNode;\n      return newNode;\n    }\n\n    if (nodeHas && node.array[idx] === value) {\n      return node;\n    }\n\n    if (didAlter) {\n      SetRef(didAlter);\n    }\n\n    newNode = editableVNode(node, ownerID);\n    if (value === undefined && idx === newNode.array.length - 1) {\n      newNode.array.pop();\n    } else {\n      newNode.array[idx] = value;\n    }\n    return newNode;\n  }\n\n  function editableVNode(node, ownerID) {\n    if (ownerID && node && ownerID === node.ownerID) {\n      return node;\n    }\n    return new VNode(node ? node.array.slice() : [], ownerID);\n  }\n\n  function listNodeFor(list, rawIndex) {\n    if (rawIndex >= getTailOffset(list._capacity)) {\n      return list._tail;\n    }\n    if (rawIndex < 1 << (list._level + SHIFT)) {\n      var node = list._root;\n      var level = list._level;\n      while (node && level > 0) {\n        node = node.array[(rawIndex >>> level) & MASK];\n        level -= SHIFT;\n      }\n      return node;\n    }\n  }\n\n  function setListBounds(list, begin, end) {\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin |= 0;\n    }\n    if (end !== undefined) {\n      end |= 0;\n    }\n    var owner = list.__ownerID || new OwnerID();\n    var oldOrigin = list._origin;\n    var oldCapacity = list._capacity;\n    var newOrigin = oldOrigin + begin;\n    var newCapacity =\n      end === undefined\n        ? oldCapacity\n        : end < 0\n          ? oldCapacity + end\n          : oldOrigin + end;\n    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n      return list;\n    }\n\n    // If it's going to end after it starts, it's empty.\n    if (newOrigin >= newCapacity) {\n      return list.clear();\n    }\n\n    var newLevel = list._level;\n    var newRoot = list._root;\n\n    // New origin might need creating a higher root.\n    var offsetShift = 0;\n    while (newOrigin + offsetShift < 0) {\n      newRoot = new VNode(\n        newRoot && newRoot.array.length ? [undefined, newRoot] : [],\n        owner\n      );\n      newLevel += SHIFT;\n      offsetShift += 1 << newLevel;\n    }\n    if (offsetShift) {\n      newOrigin += offsetShift;\n      oldOrigin += offsetShift;\n      newCapacity += offsetShift;\n      oldCapacity += offsetShift;\n    }\n\n    var oldTailOffset = getTailOffset(oldCapacity);\n    var newTailOffset = getTailOffset(newCapacity);\n\n    // New size might need creating a higher root.\n    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n      newRoot = new VNode(\n        newRoot && newRoot.array.length ? [newRoot] : [],\n        owner\n      );\n      newLevel += SHIFT;\n    }\n\n    // Locate or create the new tail.\n    var oldTail = list._tail;\n    var newTail =\n      newTailOffset < oldTailOffset\n        ? listNodeFor(list, newCapacity - 1)\n        : newTailOffset > oldTailOffset\n          ? new VNode([], owner)\n          : oldTail;\n\n    // Merge Tail into tree.\n    if (\n      oldTail &&\n      newTailOffset > oldTailOffset &&\n      newOrigin < oldCapacity &&\n      oldTail.array.length\n    ) {\n      newRoot = editableVNode(newRoot, owner);\n      var node = newRoot;\n      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n        var idx = (oldTailOffset >>> level) & MASK;\n        node = node.array[idx] = editableVNode(node.array[idx], owner);\n      }\n      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n    }\n\n    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n    if (newCapacity < oldCapacity) {\n      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n    }\n\n    // If the new origin is within the tail, then we do not need a root.\n    if (newOrigin >= newTailOffset) {\n      newOrigin -= newTailOffset;\n      newCapacity -= newTailOffset;\n      newLevel = SHIFT;\n      newRoot = null;\n      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n      // Otherwise, if the root has been trimmed, garbage collect.\n    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n      offsetShift = 0;\n\n      // Identify the new top root node of the subtree of the old root.\n      while (newRoot) {\n        var beginIndex = (newOrigin >>> newLevel) & MASK;\n        if ((beginIndex !== newTailOffset >>> newLevel) & MASK) {\n          break;\n        }\n        if (beginIndex) {\n          offsetShift += (1 << newLevel) * beginIndex;\n        }\n        newLevel -= SHIFT;\n        newRoot = newRoot.array[beginIndex];\n      }\n\n      // Trim the new sides of the new root.\n      if (newRoot && newOrigin > oldOrigin) {\n        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n      }\n      if (newRoot && newTailOffset < oldTailOffset) {\n        newRoot = newRoot.removeAfter(\n          owner,\n          newLevel,\n          newTailOffset - offsetShift\n        );\n      }\n      if (offsetShift) {\n        newOrigin -= offsetShift;\n        newCapacity -= offsetShift;\n      }\n    }\n\n    if (list.__ownerID) {\n      list.size = newCapacity - newOrigin;\n      list._origin = newOrigin;\n      list._capacity = newCapacity;\n      list._level = newLevel;\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n  }\n\n  function getTailOffset(size) {\n    return size < SIZE ? 0 : ((size - 1) >>> SHIFT) << SHIFT;\n  }\n\n  var OrderedMap = /*@__PURE__*/(function (Map$$1) {\n    function OrderedMap(value) {\n      return value === null || value === undefined\n        ? emptyOrderedMap()\n        : isOrderedMap(value)\n          ? value\n          : emptyOrderedMap().withMutations(function (map) {\n              var iter = KeyedCollection(value);\n              assertNotInfinite(iter.size);\n              iter.forEach(function (v, k) { return map.set(k, v); });\n            });\n    }\n\n    if ( Map$$1 ) OrderedMap.__proto__ = Map$$1;\n    OrderedMap.prototype = Object.create( Map$$1 && Map$$1.prototype );\n    OrderedMap.prototype.constructor = OrderedMap;\n\n    OrderedMap.of = function of (/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedMap.prototype.toString = function toString () {\n      return this.__toString('OrderedMap {', '}');\n    };\n\n    // @pragma Access\n\n    OrderedMap.prototype.get = function get (k, notSetValue) {\n      var index = this._map.get(k);\n      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n    };\n\n    // @pragma Modification\n\n    OrderedMap.prototype.clear = function clear () {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._map.clear();\n        this._list.clear();\n        return this;\n      }\n      return emptyOrderedMap();\n    };\n\n    OrderedMap.prototype.set = function set (k, v) {\n      return updateOrderedMap(this, k, v);\n    };\n\n    OrderedMap.prototype.remove = function remove (k) {\n      return updateOrderedMap(this, k, NOT_SET);\n    };\n\n    OrderedMap.prototype.wasAltered = function wasAltered () {\n      return this._map.wasAltered() || this._list.wasAltered();\n    };\n\n    OrderedMap.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      return this._list.__iterate(\n        function (entry) { return entry && fn(entry[1], entry[0], this$1); },\n        reverse\n      );\n    };\n\n    OrderedMap.prototype.__iterator = function __iterator (type, reverse) {\n      return this._list.fromEntrySeq().__iterator(type, reverse);\n    };\n\n    OrderedMap.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      var newList = this._list.__ensureOwner(ownerID);\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyOrderedMap();\n        }\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        this._list = newList;\n        return this;\n      }\n      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n    };\n\n    return OrderedMap;\n  }(Map));\n\n  OrderedMap.isOrderedMap = isOrderedMap;\n\n  OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;\n  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\n  function makeOrderedMap(map, list, ownerID, hash) {\n    var omap = Object.create(OrderedMap.prototype);\n    omap.size = map ? map.size : 0;\n    omap._map = map;\n    omap._list = list;\n    omap.__ownerID = ownerID;\n    omap.__hash = hash;\n    return omap;\n  }\n\n  var EMPTY_ORDERED_MAP;\n  function emptyOrderedMap() {\n    return (\n      EMPTY_ORDERED_MAP ||\n      (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()))\n    );\n  }\n\n  function updateOrderedMap(omap, k, v) {\n    var map = omap._map;\n    var list = omap._list;\n    var i = map.get(k);\n    var has = i !== undefined;\n    var newMap;\n    var newList;\n    if (v === NOT_SET) {\n      // removed\n      if (!has) {\n        return omap;\n      }\n      if (list.size >= SIZE && list.size >= map.size * 2) {\n        newList = list.filter(function (entry, idx) { return entry !== undefined && i !== idx; });\n        newMap = newList\n          .toKeyedSeq()\n          .map(function (entry) { return entry[0]; })\n          .flip()\n          .toMap();\n        if (omap.__ownerID) {\n          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n        }\n      } else {\n        newMap = map.remove(k);\n        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n      }\n    } else if (has) {\n      if (v === list.get(i)[1]) {\n        return omap;\n      }\n      newMap = map;\n      newList = list.set(i, [k, v]);\n    } else {\n      newMap = map.set(k, list.size);\n      newList = list.set(list.size, [k, v]);\n    }\n    if (omap.__ownerID) {\n      omap.size = newMap.size;\n      omap._map = newMap;\n      omap._list = newList;\n      omap.__hash = undefined;\n      return omap;\n    }\n    return makeOrderedMap(newMap, newList);\n  }\n\n  var IS_STACK_SYMBOL = '@@__IMMUTABLE_STACK__@@';\n\n  function isStack(maybeStack) {\n    return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);\n  }\n\n  var Stack = /*@__PURE__*/(function (IndexedCollection$$1) {\n    function Stack(value) {\n      return value === null || value === undefined\n        ? emptyStack()\n        : isStack(value)\n          ? value\n          : emptyStack().pushAll(value);\n    }\n\n    if ( IndexedCollection$$1 ) Stack.__proto__ = IndexedCollection$$1;\n    Stack.prototype = Object.create( IndexedCollection$$1 && IndexedCollection$$1.prototype );\n    Stack.prototype.constructor = Stack;\n\n    Stack.of = function of (/*...values*/) {\n      return this(arguments);\n    };\n\n    Stack.prototype.toString = function toString () {\n      return this.__toString('Stack [', ']');\n    };\n\n    // @pragma Access\n\n    Stack.prototype.get = function get (index, notSetValue) {\n      var head = this._head;\n      index = wrapIndex(this, index);\n      while (head && index--) {\n        head = head.next;\n      }\n      return head ? head.value : notSetValue;\n    };\n\n    Stack.prototype.peek = function peek () {\n      return this._head && this._head.value;\n    };\n\n    // @pragma Modification\n\n    Stack.prototype.push = function push (/*...values*/) {\n      var arguments$1 = arguments;\n\n      if (arguments.length === 0) {\n        return this;\n      }\n      var newSize = this.size + arguments.length;\n      var head = this._head;\n      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n        head = {\n          value: arguments$1[ii],\n          next: head,\n        };\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pushAll = function pushAll (iter) {\n      iter = IndexedCollection$$1(iter);\n      if (iter.size === 0) {\n        return this;\n      }\n      if (this.size === 0 && isStack(iter)) {\n        return iter;\n      }\n      assertNotInfinite(iter.size);\n      var newSize = this.size;\n      var head = this._head;\n      iter.__iterate(function (value) {\n        newSize++;\n        head = {\n          value: value,\n          next: head,\n        };\n      }, /* reverse */ true);\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pop = function pop () {\n      return this.slice(1);\n    };\n\n    Stack.prototype.clear = function clear () {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._head = undefined;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyStack();\n    };\n\n    Stack.prototype.slice = function slice (begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      var resolvedBegin = resolveBegin(begin, this.size);\n      var resolvedEnd = resolveEnd(end, this.size);\n      if (resolvedEnd !== this.size) {\n        // super.slice(begin, end);\n        return IndexedCollection$$1.prototype.slice.call(this, begin, end);\n      }\n      var newSize = this.size - resolvedBegin;\n      var head = this._head;\n      while (resolvedBegin--) {\n        head = head.next;\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    // @pragma Mutability\n\n    Stack.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyStack();\n        }\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeStack(this.size, this._head, ownerID, this.__hash);\n    };\n\n    // @pragma Iteration\n\n    Stack.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return new ArraySeq(this.toArray()).__iterate(\n          function (v, k) { return fn(v, k, this$1); },\n          reverse\n        );\n      }\n      var iterations = 0;\n      var node = this._head;\n      while (node) {\n        if (fn(node.value, iterations++, this) === false) {\n          break;\n        }\n        node = node.next;\n      }\n      return iterations;\n    };\n\n    Stack.prototype.__iterator = function __iterator (type, reverse) {\n      if (reverse) {\n        return new ArraySeq(this.toArray()).__iterator(type, reverse);\n      }\n      var iterations = 0;\n      var node = this._head;\n      return new Iterator(function () {\n        if (node) {\n          var value = node.value;\n          node = node.next;\n          return iteratorValue(type, iterations++, value);\n        }\n        return iteratorDone();\n      });\n    };\n\n    return Stack;\n  }(IndexedCollection));\n\n  Stack.isStack = isStack;\n\n  var StackPrototype = Stack.prototype;\n  StackPrototype[IS_STACK_SYMBOL] = true;\n  StackPrototype.shift = StackPrototype.pop;\n  StackPrototype.unshift = StackPrototype.push;\n  StackPrototype.unshiftAll = StackPrototype.pushAll;\n  StackPrototype.withMutations = withMutations;\n  StackPrototype.wasAltered = wasAltered;\n  StackPrototype.asImmutable = asImmutable;\n  StackPrototype['@@transducer/init'] = StackPrototype.asMutable = asMutable;\n  StackPrototype['@@transducer/step'] = function(result, arr) {\n    return result.unshift(arr);\n  };\n  StackPrototype['@@transducer/result'] = function(obj) {\n    return obj.asImmutable();\n  };\n\n  function makeStack(size, head, ownerID, hash) {\n    var map = Object.create(StackPrototype);\n    map.size = size;\n    map._head = head;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_STACK;\n  function emptyStack() {\n    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n  }\n\n  var IS_SET_SYMBOL = '@@__IMMUTABLE_SET__@@';\n\n  function isSet(maybeSet) {\n    return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);\n  }\n\n  function isOrderedSet(maybeOrderedSet) {\n    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n  }\n\n  function deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    if (\n      !isCollection(b) ||\n      (a.size !== undefined && b.size !== undefined && a.size !== b.size) ||\n      (a.__hash !== undefined &&\n        b.__hash !== undefined &&\n        a.__hash !== b.__hash) ||\n      isKeyed(a) !== isKeyed(b) ||\n      isIndexed(a) !== isIndexed(b) ||\n      isOrdered(a) !== isOrdered(b)\n    ) {\n      return false;\n    }\n\n    if (a.size === 0 && b.size === 0) {\n      return true;\n    }\n\n    var notAssociative = !isAssociative(a);\n\n    if (isOrdered(a)) {\n      var entries = a.entries();\n      return (\n        b.every(function (v, k) {\n          var entry = entries.next().value;\n          return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n        }) && entries.next().done\n      );\n    }\n\n    var flipped = false;\n\n    if (a.size === undefined) {\n      if (b.size === undefined) {\n        if (typeof a.cacheResult === 'function') {\n          a.cacheResult();\n        }\n      } else {\n        flipped = true;\n        var _ = a;\n        a = b;\n        b = _;\n      }\n    }\n\n    var allEqual = true;\n    var bSize = b.__iterate(function (v, k) {\n      if (\n        notAssociative\n          ? !a.has(v)\n          : flipped\n            ? !is(v, a.get(k, NOT_SET))\n            : !is(a.get(k, NOT_SET), v)\n      ) {\n        allEqual = false;\n        return false;\n      }\n    });\n\n    return allEqual && a.size === bSize;\n  }\n\n  /**\n   * Contributes additional methods to a constructor\n   */\n  function mixin(ctor, methods) {\n    var keyCopier = function (key) {\n      ctor.prototype[key] = methods[key];\n    };\n    Object.keys(methods).forEach(keyCopier);\n    Object.getOwnPropertySymbols &&\n      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n    return ctor;\n  }\n\n  function toJS(value) {\n    if (!value || typeof value !== 'object') {\n      return value;\n    }\n    if (!isCollection(value)) {\n      if (!isDataStructure(value)) {\n        return value;\n      }\n      value = Seq(value);\n    }\n    if (isKeyed(value)) {\n      var result$1 = {};\n      value.__iterate(function (v, k) {\n        result$1[k] = toJS(v);\n      });\n      return result$1;\n    }\n    var result = [];\n    value.__iterate(function (v) {\n      result.push(toJS(v));\n    });\n    return result;\n  }\n\n  var Set = /*@__PURE__*/(function (SetCollection$$1) {\n    function Set(value) {\n      return value === null || value === undefined\n        ? emptySet()\n        : isSet(value) && !isOrdered(value)\n          ? value\n          : emptySet().withMutations(function (set) {\n              var iter = SetCollection$$1(value);\n              assertNotInfinite(iter.size);\n              iter.forEach(function (v) { return set.add(v); });\n            });\n    }\n\n    if ( SetCollection$$1 ) Set.__proto__ = SetCollection$$1;\n    Set.prototype = Object.create( SetCollection$$1 && SetCollection$$1.prototype );\n    Set.prototype.constructor = Set;\n\n    Set.of = function of (/*...values*/) {\n      return this(arguments);\n    };\n\n    Set.fromKeys = function fromKeys (value) {\n      return this(KeyedCollection(value).keySeq());\n    };\n\n    Set.intersect = function intersect (sets) {\n      sets = Collection(sets).toArray();\n      return sets.length\n        ? SetPrototype.intersect.apply(Set(sets.pop()), sets)\n        : emptySet();\n    };\n\n    Set.union = function union (sets) {\n      sets = Collection(sets).toArray();\n      return sets.length\n        ? SetPrototype.union.apply(Set(sets.pop()), sets)\n        : emptySet();\n    };\n\n    Set.prototype.toString = function toString () {\n      return this.__toString('Set {', '}');\n    };\n\n    // @pragma Access\n\n    Set.prototype.has = function has (value) {\n      return this._map.has(value);\n    };\n\n    // @pragma Modification\n\n    Set.prototype.add = function add (value) {\n      return updateSet(this, this._map.set(value, value));\n    };\n\n    Set.prototype.remove = function remove (value) {\n      return updateSet(this, this._map.remove(value));\n    };\n\n    Set.prototype.clear = function clear () {\n      return updateSet(this, this._map.clear());\n    };\n\n    // @pragma Composition\n\n    Set.prototype.map = function map (mapper, context) {\n      var this$1 = this;\n\n      var removes = [];\n      var adds = [];\n      this.forEach(function (value) {\n        var mapped = mapper.call(context, value, value, this$1);\n        if (mapped !== value) {\n          removes.push(value);\n          adds.push(mapped);\n        }\n      });\n      return this.withMutations(function (set) {\n        removes.forEach(function (value) { return set.remove(value); });\n        adds.forEach(function (value) { return set.add(value); });\n      });\n    };\n\n    Set.prototype.union = function union () {\n      var iters = [], len = arguments.length;\n      while ( len-- ) iters[ len ] = arguments[ len ];\n\n      iters = iters.filter(function (x) { return x.size !== 0; });\n      if (iters.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n        return this.constructor(iters[0]);\n      }\n      return this.withMutations(function (set) {\n        for (var ii = 0; ii < iters.length; ii++) {\n          SetCollection$$1(iters[ii]).forEach(function (value) { return set.add(value); });\n        }\n      });\n    };\n\n    Set.prototype.intersect = function intersect () {\n      var iters = [], len = arguments.length;\n      while ( len-- ) iters[ len ] = arguments[ len ];\n\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function (iter) { return SetCollection$$1(iter); });\n      var toRemove = [];\n      this.forEach(function (value) {\n        if (!iters.every(function (iter) { return iter.includes(value); })) {\n          toRemove.push(value);\n        }\n      });\n      return this.withMutations(function (set) {\n        toRemove.forEach(function (value) {\n          set.remove(value);\n        });\n      });\n    };\n\n    Set.prototype.subtract = function subtract () {\n      var iters = [], len = arguments.length;\n      while ( len-- ) iters[ len ] = arguments[ len ];\n\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function (iter) { return SetCollection$$1(iter); });\n      var toRemove = [];\n      this.forEach(function (value) {\n        if (iters.some(function (iter) { return iter.includes(value); })) {\n          toRemove.push(value);\n        }\n      });\n      return this.withMutations(function (set) {\n        toRemove.forEach(function (value) {\n          set.remove(value);\n        });\n      });\n    };\n\n    Set.prototype.sort = function sort (comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator));\n    };\n\n    Set.prototype.sortBy = function sortBy (mapper, comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator, mapper));\n    };\n\n    Set.prototype.wasAltered = function wasAltered () {\n      return this._map.wasAltered();\n    };\n\n    Set.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      return this._map.__iterate(function (k) { return fn(k, k, this$1); }, reverse);\n    };\n\n    Set.prototype.__iterator = function __iterator (type, reverse) {\n      return this._map.__iterator(type, reverse);\n    };\n\n    Set.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        if (this.size === 0) {\n          return this.__empty();\n        }\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return this.__make(newMap, ownerID);\n    };\n\n    return Set;\n  }(SetCollection));\n\n  Set.isSet = isSet;\n\n  var SetPrototype = Set.prototype;\n  SetPrototype[IS_SET_SYMBOL] = true;\n  SetPrototype[DELETE] = SetPrototype.remove;\n  SetPrototype.merge = SetPrototype.concat = SetPrototype.union;\n  SetPrototype.withMutations = withMutations;\n  SetPrototype.asImmutable = asImmutable;\n  SetPrototype['@@transducer/init'] = SetPrototype.asMutable = asMutable;\n  SetPrototype['@@transducer/step'] = function(result, arr) {\n    return result.add(arr);\n  };\n  SetPrototype['@@transducer/result'] = function(obj) {\n    return obj.asImmutable();\n  };\n\n  SetPrototype.__empty = emptySet;\n  SetPrototype.__make = makeSet;\n\n  function updateSet(set, newMap) {\n    if (set.__ownerID) {\n      set.size = newMap.size;\n      set._map = newMap;\n      return set;\n    }\n    return newMap === set._map\n      ? set\n      : newMap.size === 0\n        ? set.__empty()\n        : set.__make(newMap);\n  }\n\n  function makeSet(map, ownerID) {\n    var set = Object.create(SetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_SET;\n  function emptySet() {\n    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n  }\n\n  /**\n   * Returns a lazy seq of nums from start (inclusive) to end\n   * (exclusive), by step, where start defaults to 0, step to 1, and end to\n   * infinity. When start is equal to end, returns empty list.\n   */\n  var Range = /*@__PURE__*/(function (IndexedSeq$$1) {\n    function Range(start, end, step) {\n      if (!(this instanceof Range)) {\n        return new Range(start, end, step);\n      }\n      invariant(step !== 0, 'Cannot step a Range by 0');\n      start = start || 0;\n      if (end === undefined) {\n        end = Infinity;\n      }\n      step = step === undefined ? 1 : Math.abs(step);\n      if (end < start) {\n        step = -step;\n      }\n      this._start = start;\n      this._end = end;\n      this._step = step;\n      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n      if (this.size === 0) {\n        if (EMPTY_RANGE) {\n          return EMPTY_RANGE;\n        }\n        EMPTY_RANGE = this;\n      }\n    }\n\n    if ( IndexedSeq$$1 ) Range.__proto__ = IndexedSeq$$1;\n    Range.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );\n    Range.prototype.constructor = Range;\n\n    Range.prototype.toString = function toString () {\n      if (this.size === 0) {\n        return 'Range []';\n      }\n      return (\n        'Range [ ' +\n        this._start +\n        '...' +\n        this._end +\n        (this._step !== 1 ? ' by ' + this._step : '') +\n        ' ]'\n      );\n    };\n\n    Range.prototype.get = function get (index, notSetValue) {\n      return this.has(index)\n        ? this._start + wrapIndex(this, index) * this._step\n        : notSetValue;\n    };\n\n    Range.prototype.includes = function includes (searchValue) {\n      var possibleIndex = (searchValue - this._start) / this._step;\n      return (\n        possibleIndex >= 0 &&\n        possibleIndex < this.size &&\n        possibleIndex === Math.floor(possibleIndex)\n      );\n    };\n\n    Range.prototype.slice = function slice (begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      begin = resolveBegin(begin, this.size);\n      end = resolveEnd(end, this.size);\n      if (end <= begin) {\n        return new Range(0, 0);\n      }\n      return new Range(\n        this.get(begin, this._end),\n        this.get(end, this._end),\n        this._step\n      );\n    };\n\n    Range.prototype.indexOf = function indexOf (searchValue) {\n      var offsetValue = searchValue - this._start;\n      if (offsetValue % this._step === 0) {\n        var index = offsetValue / this._step;\n        if (index >= 0 && index < this.size) {\n          return index;\n        }\n      }\n      return -1;\n    };\n\n    Range.prototype.lastIndexOf = function lastIndexOf (searchValue) {\n      return this.indexOf(searchValue);\n    };\n\n    Range.prototype.__iterate = function __iterate (fn, reverse) {\n      var size = this.size;\n      var step = this._step;\n      var value = reverse ? this._start + (size - 1) * step : this._start;\n      var i = 0;\n      while (i !== size) {\n        if (fn(value, reverse ? size - ++i : i++, this) === false) {\n          break;\n        }\n        value += reverse ? -step : step;\n      }\n      return i;\n    };\n\n    Range.prototype.__iterator = function __iterator (type, reverse) {\n      var size = this.size;\n      var step = this._step;\n      var value = reverse ? this._start + (size - 1) * step : this._start;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n        var v = value;\n        value += reverse ? -step : step;\n        return iteratorValue(type, reverse ? size - ++i : i++, v);\n      });\n    };\n\n    Range.prototype.equals = function equals (other) {\n      return other instanceof Range\n        ? this._start === other._start &&\n            this._end === other._end &&\n            this._step === other._step\n        : deepEqual(this, other);\n    };\n\n    return Range;\n  }(IndexedSeq));\n\n  var EMPTY_RANGE;\n\n  function getIn(collection, searchKeyPath, notSetValue) {\n    var keyPath = coerceKeyPath(searchKeyPath);\n    var i = 0;\n    while (i !== keyPath.length) {\n      collection = get(collection, keyPath[i++], NOT_SET);\n      if (collection === NOT_SET) {\n        return notSetValue;\n      }\n    }\n    return collection;\n  }\n\n  function getIn$1(searchKeyPath, notSetValue) {\n    return getIn(this, searchKeyPath, notSetValue);\n  }\n\n  function hasIn(collection, keyPath) {\n    return getIn(collection, keyPath, NOT_SET) !== NOT_SET;\n  }\n\n  function hasIn$1(searchKeyPath) {\n    return hasIn(this, searchKeyPath);\n  }\n\n  function toObject() {\n    assertNotInfinite(this.size);\n    var object = {};\n    this.__iterate(function (v, k) {\n      object[k] = v;\n    });\n    return object;\n  }\n\n  // Note: all of these methods are deprecated.\n  Collection.isIterable = isCollection;\n  Collection.isKeyed = isKeyed;\n  Collection.isIndexed = isIndexed;\n  Collection.isAssociative = isAssociative;\n  Collection.isOrdered = isOrdered;\n\n  Collection.Iterator = Iterator;\n\n  mixin(Collection, {\n    // ### Conversion to other types\n\n    toArray: function toArray() {\n      assertNotInfinite(this.size);\n      var array = new Array(this.size || 0);\n      var useTuples = isKeyed(this);\n      var i = 0;\n      this.__iterate(function (v, k) {\n        // Keyed collections produce an array of tuples.\n        array[i++] = useTuples ? [k, v] : v;\n      });\n      return array;\n    },\n\n    toIndexedSeq: function toIndexedSeq() {\n      return new ToIndexedSequence(this);\n    },\n\n    toJS: function toJS$1() {\n      return toJS(this);\n    },\n\n    toKeyedSeq: function toKeyedSeq() {\n      return new ToKeyedSequence(this, true);\n    },\n\n    toMap: function toMap() {\n      // Use Late Binding here to solve the circular dependency.\n      return Map(this.toKeyedSeq());\n    },\n\n    toObject: toObject,\n\n    toOrderedMap: function toOrderedMap() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedMap(this.toKeyedSeq());\n    },\n\n    toOrderedSet: function toOrderedSet() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSet: function toSet() {\n      // Use Late Binding here to solve the circular dependency.\n      return Set(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSetSeq: function toSetSeq() {\n      return new ToSetSequence(this);\n    },\n\n    toSeq: function toSeq() {\n      return isIndexed(this)\n        ? this.toIndexedSeq()\n        : isKeyed(this)\n          ? this.toKeyedSeq()\n          : this.toSetSeq();\n    },\n\n    toStack: function toStack() {\n      // Use Late Binding here to solve the circular dependency.\n      return Stack(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toList: function toList() {\n      // Use Late Binding here to solve the circular dependency.\n      return List(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    // ### Common JavaScript methods and properties\n\n    toString: function toString() {\n      return '[Collection]';\n    },\n\n    __toString: function __toString(head, tail) {\n      if (this.size === 0) {\n        return head + tail;\n      }\n      return (\n        head +\n        ' ' +\n        this.toSeq()\n          .map(this.__toStringMapper)\n          .join(', ') +\n        ' ' +\n        tail\n      );\n    },\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    concat: function concat() {\n      var values = [], len = arguments.length;\n      while ( len-- ) values[ len ] = arguments[ len ];\n\n      return reify(this, concatFactory(this, values));\n    },\n\n    includes: function includes(searchValue) {\n      return this.some(function (value) { return is(value, searchValue); });\n    },\n\n    entries: function entries() {\n      return this.__iterator(ITERATE_ENTRIES);\n    },\n\n    every: function every(predicate, context) {\n      assertNotInfinite(this.size);\n      var returnValue = true;\n      this.__iterate(function (v, k, c) {\n        if (!predicate.call(context, v, k, c)) {\n          returnValue = false;\n          return false;\n        }\n      });\n      return returnValue;\n    },\n\n    filter: function filter(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, true));\n    },\n\n    find: function find(predicate, context, notSetValue) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[1] : notSetValue;\n    },\n\n    forEach: function forEach(sideEffect, context) {\n      assertNotInfinite(this.size);\n      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n    },\n\n    join: function join(separator) {\n      assertNotInfinite(this.size);\n      separator = separator !== undefined ? '' + separator : ',';\n      var joined = '';\n      var isFirst = true;\n      this.__iterate(function (v) {\n        isFirst ? (isFirst = false) : (joined += separator);\n        joined += v !== null && v !== undefined ? v.toString() : '';\n      });\n      return joined;\n    },\n\n    keys: function keys() {\n      return this.__iterator(ITERATE_KEYS);\n    },\n\n    map: function map(mapper, context) {\n      return reify(this, mapFactory(this, mapper, context));\n    },\n\n    reduce: function reduce$1(reducer, initialReduction, context) {\n      return reduce(\n        this,\n        reducer,\n        initialReduction,\n        context,\n        arguments.length < 2,\n        false\n      );\n    },\n\n    reduceRight: function reduceRight(reducer, initialReduction, context) {\n      return reduce(\n        this,\n        reducer,\n        initialReduction,\n        context,\n        arguments.length < 2,\n        true\n      );\n    },\n\n    reverse: function reverse() {\n      return reify(this, reverseFactory(this, true));\n    },\n\n    slice: function slice(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, true));\n    },\n\n    some: function some(predicate, context) {\n      return !this.every(not(predicate), context);\n    },\n\n    sort: function sort(comparator) {\n      return reify(this, sortFactory(this, comparator));\n    },\n\n    values: function values() {\n      return this.__iterator(ITERATE_VALUES);\n    },\n\n    // ### More sequential methods\n\n    butLast: function butLast() {\n      return this.slice(0, -1);\n    },\n\n    isEmpty: function isEmpty() {\n      return this.size !== undefined ? this.size === 0 : !this.some(function () { return true; });\n    },\n\n    count: function count(predicate, context) {\n      return ensureSize(\n        predicate ? this.toSeq().filter(predicate, context) : this\n      );\n    },\n\n    countBy: function countBy(grouper, context) {\n      return countByFactory(this, grouper, context);\n    },\n\n    equals: function equals(other) {\n      return deepEqual(this, other);\n    },\n\n    entrySeq: function entrySeq() {\n      var collection = this;\n      if (collection._cache) {\n        // We cache as an entries array, so we can just return the cache!\n        return new ArraySeq(collection._cache);\n      }\n      var entriesSequence = collection\n        .toSeq()\n        .map(entryMapper)\n        .toIndexedSeq();\n      entriesSequence.fromEntrySeq = function () { return collection.toSeq(); };\n      return entriesSequence;\n    },\n\n    filterNot: function filterNot(predicate, context) {\n      return this.filter(not(predicate), context);\n    },\n\n    findEntry: function findEntry(predicate, context, notSetValue) {\n      var found = notSetValue;\n      this.__iterate(function (v, k, c) {\n        if (predicate.call(context, v, k, c)) {\n          found = [k, v];\n          return false;\n        }\n      });\n      return found;\n    },\n\n    findKey: function findKey(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry && entry[0];\n    },\n\n    findLast: function findLast(predicate, context, notSetValue) {\n      return this.toKeyedSeq()\n        .reverse()\n        .find(predicate, context, notSetValue);\n    },\n\n    findLastEntry: function findLastEntry(predicate, context, notSetValue) {\n      return this.toKeyedSeq()\n        .reverse()\n        .findEntry(predicate, context, notSetValue);\n    },\n\n    findLastKey: function findLastKey(predicate, context) {\n      return this.toKeyedSeq()\n        .reverse()\n        .findKey(predicate, context);\n    },\n\n    first: function first(notSetValue) {\n      return this.find(returnTrue, null, notSetValue);\n    },\n\n    flatMap: function flatMap(mapper, context) {\n      return reify(this, flatMapFactory(this, mapper, context));\n    },\n\n    flatten: function flatten(depth) {\n      return reify(this, flattenFactory(this, depth, true));\n    },\n\n    fromEntrySeq: function fromEntrySeq() {\n      return new FromEntriesSequence(this);\n    },\n\n    get: function get(searchKey, notSetValue) {\n      return this.find(function (_, key) { return is(key, searchKey); }, undefined, notSetValue);\n    },\n\n    getIn: getIn$1,\n\n    groupBy: function groupBy(grouper, context) {\n      return groupByFactory(this, grouper, context);\n    },\n\n    has: function has(searchKey) {\n      return this.get(searchKey, NOT_SET) !== NOT_SET;\n    },\n\n    hasIn: hasIn$1,\n\n    isSubset: function isSubset(iter) {\n      iter = typeof iter.includes === 'function' ? iter : Collection(iter);\n      return this.every(function (value) { return iter.includes(value); });\n    },\n\n    isSuperset: function isSuperset(iter) {\n      iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);\n      return iter.isSubset(this);\n    },\n\n    keyOf: function keyOf(searchValue) {\n      return this.findKey(function (value) { return is(value, searchValue); });\n    },\n\n    keySeq: function keySeq() {\n      return this.toSeq()\n        .map(keyMapper)\n        .toIndexedSeq();\n    },\n\n    last: function last(notSetValue) {\n      return this.toSeq()\n        .reverse()\n        .first(notSetValue);\n    },\n\n    lastKeyOf: function lastKeyOf(searchValue) {\n      return this.toKeyedSeq()\n        .reverse()\n        .keyOf(searchValue);\n    },\n\n    max: function max(comparator) {\n      return maxFactory(this, comparator);\n    },\n\n    maxBy: function maxBy(mapper, comparator) {\n      return maxFactory(this, comparator, mapper);\n    },\n\n    min: function min(comparator) {\n      return maxFactory(\n        this,\n        comparator ? neg(comparator) : defaultNegComparator\n      );\n    },\n\n    minBy: function minBy(mapper, comparator) {\n      return maxFactory(\n        this,\n        comparator ? neg(comparator) : defaultNegComparator,\n        mapper\n      );\n    },\n\n    rest: function rest() {\n      return this.slice(1);\n    },\n\n    skip: function skip(amount) {\n      return amount === 0 ? this : this.slice(Math.max(0, amount));\n    },\n\n    skipLast: function skipLast(amount) {\n      return amount === 0 ? this : this.slice(0, -Math.max(0, amount));\n    },\n\n    skipWhile: function skipWhile(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, true));\n    },\n\n    skipUntil: function skipUntil(predicate, context) {\n      return this.skipWhile(not(predicate), context);\n    },\n\n    sortBy: function sortBy(mapper, comparator) {\n      return reify(this, sortFactory(this, comparator, mapper));\n    },\n\n    take: function take(amount) {\n      return this.slice(0, Math.max(0, amount));\n    },\n\n    takeLast: function takeLast(amount) {\n      return this.slice(-Math.max(0, amount));\n    },\n\n    takeWhile: function takeWhile(predicate, context) {\n      return reify(this, takeWhileFactory(this, predicate, context));\n    },\n\n    takeUntil: function takeUntil(predicate, context) {\n      return this.takeWhile(not(predicate), context);\n    },\n\n    update: function update(fn) {\n      return fn(this);\n    },\n\n    valueSeq: function valueSeq() {\n      return this.toIndexedSeq();\n    },\n\n    // ### Hashable Object\n\n    hashCode: function hashCode() {\n      return this.__hash || (this.__hash = hashCollection(this));\n    },\n\n    // ### Internal\n\n    // abstract __iterate(fn, reverse)\n\n    // abstract __iterator(type, reverse)\n  });\n\n  var CollectionPrototype = Collection.prototype;\n  CollectionPrototype[IS_COLLECTION_SYMBOL] = true;\n  CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;\n  CollectionPrototype.toJSON = CollectionPrototype.toArray;\n  CollectionPrototype.__toStringMapper = quoteString;\n  CollectionPrototype.inspect = CollectionPrototype.toSource = function() {\n    return this.toString();\n  };\n  CollectionPrototype.chain = CollectionPrototype.flatMap;\n  CollectionPrototype.contains = CollectionPrototype.includes;\n\n  mixin(KeyedCollection, {\n    // ### More sequential methods\n\n    flip: function flip() {\n      return reify(this, flipFactory(this));\n    },\n\n    mapEntries: function mapEntries(mapper, context) {\n      var this$1 = this;\n\n      var iterations = 0;\n      return reify(\n        this,\n        this.toSeq()\n          .map(function (v, k) { return mapper.call(context, [k, v], iterations++, this$1); })\n          .fromEntrySeq()\n      );\n    },\n\n    mapKeys: function mapKeys(mapper, context) {\n      var this$1 = this;\n\n      return reify(\n        this,\n        this.toSeq()\n          .flip()\n          .map(function (k, v) { return mapper.call(context, k, v, this$1); })\n          .flip()\n      );\n    },\n  });\n\n  var KeyedCollectionPrototype = KeyedCollection.prototype;\n  KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;\n  KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;\n  KeyedCollectionPrototype.toJSON = toObject;\n  KeyedCollectionPrototype.__toStringMapper = function (v, k) { return quoteString(k) + ': ' + quoteString(v); };\n\n  mixin(IndexedCollection, {\n    // ### Conversion to other types\n\n    toKeyedSeq: function toKeyedSeq() {\n      return new ToKeyedSequence(this, false);\n    },\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    filter: function filter(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, false));\n    },\n\n    findIndex: function findIndex(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    indexOf: function indexOf(searchValue) {\n      var key = this.keyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    lastIndexOf: function lastIndexOf(searchValue) {\n      var key = this.lastKeyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    reverse: function reverse() {\n      return reify(this, reverseFactory(this, false));\n    },\n\n    slice: function slice(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, false));\n    },\n\n    splice: function splice(index, removeNum /*, ...values*/) {\n      var numArgs = arguments.length;\n      removeNum = Math.max(removeNum || 0, 0);\n      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n        return this;\n      }\n      // If index is negative, it should resolve relative to the size of the\n      // collection. However size may be expensive to compute if not cached, so\n      // only call count() if the number is in fact negative.\n      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n      var spliced = this.slice(0, index);\n      return reify(\n        this,\n        numArgs === 1\n          ? spliced\n          : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n      );\n    },\n\n    // ### More collection methods\n\n    findLastIndex: function findLastIndex(predicate, context) {\n      var entry = this.findLastEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    first: function first(notSetValue) {\n      return this.get(0, notSetValue);\n    },\n\n    flatten: function flatten(depth) {\n      return reify(this, flattenFactory(this, depth, false));\n    },\n\n    get: function get(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return index < 0 ||\n        (this.size === Infinity || (this.size !== undefined && index > this.size))\n        ? notSetValue\n        : this.find(function (_, key) { return key === index; }, undefined, notSetValue);\n    },\n\n    has: function has(index) {\n      index = wrapIndex(this, index);\n      return (\n        index >= 0 &&\n        (this.size !== undefined\n          ? this.size === Infinity || index < this.size\n          : this.indexOf(index) !== -1)\n      );\n    },\n\n    interpose: function interpose(separator) {\n      return reify(this, interposeFactory(this, separator));\n    },\n\n    interleave: function interleave(/*...collections*/) {\n      var collections = [this].concat(arrCopy(arguments));\n      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);\n      var interleaved = zipped.flatten(true);\n      if (zipped.size) {\n        interleaved.size = zipped.size * collections.length;\n      }\n      return reify(this, interleaved);\n    },\n\n    keySeq: function keySeq() {\n      return Range(0, this.size);\n    },\n\n    last: function last(notSetValue) {\n      return this.get(-1, notSetValue);\n    },\n\n    skipWhile: function skipWhile(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, false));\n    },\n\n    zip: function zip(/*, ...collections */) {\n      var collections = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, collections));\n    },\n\n    zipAll: function zipAll(/*, ...collections */) {\n      var collections = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, collections, true));\n    },\n\n    zipWith: function zipWith(zipper /*, ...collections */) {\n      var collections = arrCopy(arguments);\n      collections[0] = this;\n      return reify(this, zipWithFactory(this, zipper, collections));\n    },\n  });\n\n  var IndexedCollectionPrototype = IndexedCollection.prototype;\n  IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;\n  IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;\n\n  mixin(SetCollection, {\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    get: function get(value, notSetValue) {\n      return this.has(value) ? value : notSetValue;\n    },\n\n    includes: function includes(value) {\n      return this.has(value);\n    },\n\n    // ### More sequential methods\n\n    keySeq: function keySeq() {\n      return this.valueSeq();\n    },\n  });\n\n  SetCollection.prototype.has = CollectionPrototype.includes;\n  SetCollection.prototype.contains = SetCollection.prototype.includes;\n\n  // Mixin subclasses\n\n  mixin(KeyedSeq, KeyedCollection.prototype);\n  mixin(IndexedSeq, IndexedCollection.prototype);\n  mixin(SetSeq, SetCollection.prototype);\n\n  // #pragma Helper functions\n\n  function reduce(collection, reducer, reduction, context, useFirst, reverse) {\n    assertNotInfinite(collection.size);\n    collection.__iterate(function (v, k, c) {\n      if (useFirst) {\n        useFirst = false;\n        reduction = v;\n      } else {\n        reduction = reducer.call(context, reduction, v, k, c);\n      }\n    }, reverse);\n    return reduction;\n  }\n\n  function keyMapper(v, k) {\n    return k;\n  }\n\n  function entryMapper(v, k) {\n    return [k, v];\n  }\n\n  function not(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  }\n\n  function neg(predicate) {\n    return function() {\n      return -predicate.apply(this, arguments);\n    };\n  }\n\n  function defaultZipper() {\n    return arrCopy(arguments);\n  }\n\n  function defaultNegComparator(a, b) {\n    return a < b ? 1 : a > b ? -1 : 0;\n  }\n\n  function hashCollection(collection) {\n    if (collection.size === Infinity) {\n      return 0;\n    }\n    var ordered = isOrdered(collection);\n    var keyed = isKeyed(collection);\n    var h = ordered ? 1 : 0;\n    var size = collection.__iterate(\n      keyed\n        ? ordered\n          ? function (v, k) {\n              h = (31 * h + hashMerge(hash(v), hash(k))) | 0;\n            }\n          : function (v, k) {\n              h = (h + hashMerge(hash(v), hash(k))) | 0;\n            }\n        : ordered\n          ? function (v) {\n              h = (31 * h + hash(v)) | 0;\n            }\n          : function (v) {\n              h = (h + hash(v)) | 0;\n            }\n    );\n    return murmurHashOfSize(size, h);\n  }\n\n  function murmurHashOfSize(size, h) {\n    h = imul(h, 0xcc9e2d51);\n    h = imul((h << 15) | (h >>> -15), 0x1b873593);\n    h = imul((h << 13) | (h >>> -13), 5);\n    h = ((h + 0xe6546b64) | 0) ^ size;\n    h = imul(h ^ (h >>> 16), 0x85ebca6b);\n    h = imul(h ^ (h >>> 13), 0xc2b2ae35);\n    h = smi(h ^ (h >>> 16));\n    return h;\n  }\n\n  function hashMerge(a, b) {\n    return (a ^ (b + 0x9e3779b9 + (a << 6) + (a >> 2))) | 0; // int\n  }\n\n  var OrderedSet = /*@__PURE__*/(function (Set$$1) {\n    function OrderedSet(value) {\n      return value === null || value === undefined\n        ? emptyOrderedSet()\n        : isOrderedSet(value)\n          ? value\n          : emptyOrderedSet().withMutations(function (set) {\n              var iter = SetCollection(value);\n              assertNotInfinite(iter.size);\n              iter.forEach(function (v) { return set.add(v); });\n            });\n    }\n\n    if ( Set$$1 ) OrderedSet.__proto__ = Set$$1;\n    OrderedSet.prototype = Object.create( Set$$1 && Set$$1.prototype );\n    OrderedSet.prototype.constructor = OrderedSet;\n\n    OrderedSet.of = function of (/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedSet.fromKeys = function fromKeys (value) {\n      return this(KeyedCollection(value).keySeq());\n    };\n\n    OrderedSet.prototype.toString = function toString () {\n      return this.__toString('OrderedSet {', '}');\n    };\n\n    return OrderedSet;\n  }(Set));\n\n  OrderedSet.isOrderedSet = isOrderedSet;\n\n  var OrderedSetPrototype = OrderedSet.prototype;\n  OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;\n  OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;\n  OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;\n\n  OrderedSetPrototype.__empty = emptyOrderedSet;\n  OrderedSetPrototype.__make = makeOrderedSet;\n\n  function makeOrderedSet(map, ownerID) {\n    var set = Object.create(OrderedSetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_ORDERED_SET;\n  function emptyOrderedSet() {\n    return (\n      EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()))\n    );\n  }\n\n  var Record = function Record(defaultValues, name) {\n    var hasInitialized;\n\n    var RecordType = function Record(values) {\n      var this$1 = this;\n\n      if (values instanceof RecordType) {\n        return values;\n      }\n      if (!(this instanceof RecordType)) {\n        return new RecordType(values);\n      }\n      if (!hasInitialized) {\n        hasInitialized = true;\n        var keys = Object.keys(defaultValues);\n        var indices = (RecordTypePrototype._indices = {});\n        // Deprecated: left to attempt not to break any external code which\n        // relies on a ._name property existing on record instances.\n        // Use Record.getDescriptiveName() instead\n        RecordTypePrototype._name = name;\n        RecordTypePrototype._keys = keys;\n        RecordTypePrototype._defaultValues = defaultValues;\n        for (var i = 0; i < keys.length; i++) {\n          var propName = keys[i];\n          indices[propName] = i;\n          if (RecordTypePrototype[propName]) {\n            /* eslint-disable no-console */\n            typeof console === 'object' &&\n              console.warn &&\n              console.warn(\n                'Cannot define ' +\n                  recordName(this) +\n                  ' with property \"' +\n                  propName +\n                  '\" since that property name is part of the Record API.'\n              );\n            /* eslint-enable no-console */\n          } else {\n            setProp(RecordTypePrototype, propName);\n          }\n        }\n      }\n      this.__ownerID = undefined;\n      this._values = List().withMutations(function (l) {\n        l.setSize(this$1._keys.length);\n        KeyedCollection(values).forEach(function (v, k) {\n          l.set(this$1._indices[k], v === this$1._defaultValues[k] ? undefined : v);\n        });\n      });\n    };\n\n    var RecordTypePrototype = (RecordType.prototype = Object.create(\n      RecordPrototype\n    ));\n    RecordTypePrototype.constructor = RecordType;\n\n    if (name) {\n      RecordType.displayName = name;\n    }\n\n    return RecordType;\n  };\n\n  Record.prototype.toString = function toString () {\n    var str = recordName(this) + ' { ';\n    var keys = this._keys;\n    var k;\n    for (var i = 0, l = keys.length; i !== l; i++) {\n      k = keys[i];\n      str += (i ? ', ' : '') + k + ': ' + quoteString(this.get(k));\n    }\n    return str + ' }';\n  };\n\n  Record.prototype.equals = function equals (other) {\n    return (\n      this === other ||\n      (other &&\n        this._keys === other._keys &&\n        recordSeq(this).equals(recordSeq(other)))\n    );\n  };\n\n  Record.prototype.hashCode = function hashCode () {\n    return recordSeq(this).hashCode();\n  };\n\n  // @pragma Access\n\n  Record.prototype.has = function has (k) {\n    return this._indices.hasOwnProperty(k);\n  };\n\n  Record.prototype.get = function get (k, notSetValue) {\n    if (!this.has(k)) {\n      return notSetValue;\n    }\n    var index = this._indices[k];\n    var value = this._values.get(index);\n    return value === undefined ? this._defaultValues[k] : value;\n  };\n\n  // @pragma Modification\n\n  Record.prototype.set = function set (k, v) {\n    if (this.has(k)) {\n      var newValues = this._values.set(\n        this._indices[k],\n        v === this._defaultValues[k] ? undefined : v\n      );\n      if (newValues !== this._values && !this.__ownerID) {\n        return makeRecord(this, newValues);\n      }\n    }\n    return this;\n  };\n\n  Record.prototype.remove = function remove (k) {\n    return this.set(k);\n  };\n\n  Record.prototype.clear = function clear () {\n    var newValues = this._values.clear().setSize(this._keys.length);\n    return this.__ownerID ? this : makeRecord(this, newValues);\n  };\n\n  Record.prototype.wasAltered = function wasAltered () {\n    return this._values.wasAltered();\n  };\n\n  Record.prototype.toSeq = function toSeq () {\n    return recordSeq(this);\n  };\n\n  Record.prototype.toJS = function toJS$1 () {\n    return toJS(this);\n  };\n\n  Record.prototype.entries = function entries () {\n    return this.__iterator(ITERATE_ENTRIES);\n  };\n\n  Record.prototype.__iterator = function __iterator (type, reverse) {\n    return recordSeq(this).__iterator(type, reverse);\n  };\n\n  Record.prototype.__iterate = function __iterate (fn, reverse) {\n    return recordSeq(this).__iterate(fn, reverse);\n  };\n\n  Record.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    var newValues = this._values.__ensureOwner(ownerID);\n    if (!ownerID) {\n      this.__ownerID = ownerID;\n      this._values = newValues;\n      return this;\n    }\n    return makeRecord(this, newValues, ownerID);\n  };\n\n  Record.isRecord = isRecord;\n  Record.getDescriptiveName = recordName;\n  var RecordPrototype = Record.prototype;\n  RecordPrototype[IS_RECORD_SYMBOL] = true;\n  RecordPrototype[DELETE] = RecordPrototype.remove;\n  RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;\n  RecordPrototype.getIn = getIn$1;\n  RecordPrototype.hasIn = CollectionPrototype.hasIn;\n  RecordPrototype.merge = merge;\n  RecordPrototype.mergeWith = mergeWith;\n  RecordPrototype.mergeIn = mergeIn;\n  RecordPrototype.mergeDeep = mergeDeep$1;\n  RecordPrototype.mergeDeepWith = mergeDeepWith$1;\n  RecordPrototype.mergeDeepIn = mergeDeepIn;\n  RecordPrototype.setIn = setIn$1;\n  RecordPrototype.update = update$1;\n  RecordPrototype.updateIn = updateIn$1;\n  RecordPrototype.withMutations = withMutations;\n  RecordPrototype.asMutable = asMutable;\n  RecordPrototype.asImmutable = asImmutable;\n  RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;\n  RecordPrototype.toJSON = RecordPrototype.toObject =\n    CollectionPrototype.toObject;\n  RecordPrototype.inspect = RecordPrototype.toSource = function() {\n    return this.toString();\n  };\n\n  function makeRecord(likeRecord, values, ownerID) {\n    var record = Object.create(Object.getPrototypeOf(likeRecord));\n    record._values = values;\n    record.__ownerID = ownerID;\n    return record;\n  }\n\n  function recordName(record) {\n    return record.constructor.displayName || record.constructor.name || 'Record';\n  }\n\n  function recordSeq(record) {\n    return keyedSeqFromValue(record._keys.map(function (k) { return [k, record.get(k)]; }));\n  }\n\n  function setProp(prototype, name) {\n    try {\n      Object.defineProperty(prototype, name, {\n        get: function() {\n          return this.get(name);\n        },\n        set: function(value) {\n          invariant(this.__ownerID, 'Cannot set on an immutable record.');\n          this.set(name, value);\n        },\n      });\n    } catch (error) {\n      // Object.defineProperty failed. Probably IE8.\n    }\n  }\n\n  /**\n   * Returns a lazy Seq of `value` repeated `times` times. When `times` is\n   * undefined, returns an infinite sequence of `value`.\n   */\n  var Repeat = /*@__PURE__*/(function (IndexedSeq$$1) {\n    function Repeat(value, times) {\n      if (!(this instanceof Repeat)) {\n        return new Repeat(value, times);\n      }\n      this._value = value;\n      this.size = times === undefined ? Infinity : Math.max(0, times);\n      if (this.size === 0) {\n        if (EMPTY_REPEAT) {\n          return EMPTY_REPEAT;\n        }\n        EMPTY_REPEAT = this;\n      }\n    }\n\n    if ( IndexedSeq$$1 ) Repeat.__proto__ = IndexedSeq$$1;\n    Repeat.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );\n    Repeat.prototype.constructor = Repeat;\n\n    Repeat.prototype.toString = function toString () {\n      if (this.size === 0) {\n        return 'Repeat []';\n      }\n      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n    };\n\n    Repeat.prototype.get = function get (index, notSetValue) {\n      return this.has(index) ? this._value : notSetValue;\n    };\n\n    Repeat.prototype.includes = function includes (searchValue) {\n      return is(this._value, searchValue);\n    };\n\n    Repeat.prototype.slice = function slice (begin, end) {\n      var size = this.size;\n      return wholeSlice(begin, end, size)\n        ? this\n        : new Repeat(\n            this._value,\n            resolveEnd(end, size) - resolveBegin(begin, size)\n          );\n    };\n\n    Repeat.prototype.reverse = function reverse () {\n      return this;\n    };\n\n    Repeat.prototype.indexOf = function indexOf (searchValue) {\n      if (is(this._value, searchValue)) {\n        return 0;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.lastIndexOf = function lastIndexOf (searchValue) {\n      if (is(this._value, searchValue)) {\n        return this.size;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.__iterate = function __iterate (fn, reverse) {\n      var size = this.size;\n      var i = 0;\n      while (i !== size) {\n        if (fn(this._value, reverse ? size - ++i : i++, this) === false) {\n          break;\n        }\n      }\n      return i;\n    };\n\n    Repeat.prototype.__iterator = function __iterator (type, reverse) {\n      var this$1 = this;\n\n      var size = this.size;\n      var i = 0;\n      return new Iterator(\n        function () { return i === size\n            ? iteratorDone()\n            : iteratorValue(type, reverse ? size - ++i : i++, this$1._value); }\n      );\n    };\n\n    Repeat.prototype.equals = function equals (other) {\n      return other instanceof Repeat\n        ? is(this._value, other._value)\n        : deepEqual(other);\n    };\n\n    return Repeat;\n  }(IndexedSeq));\n\n  var EMPTY_REPEAT;\n\n  function fromJS(value, converter) {\n    return fromJSWith(\n      [],\n      converter || defaultConverter,\n      value,\n      '',\n      converter && converter.length > 2 ? [] : undefined,\n      { '': value }\n    );\n  }\n\n  function fromJSWith(stack, converter, value, key, keyPath, parentValue) {\n    var toSeq = Array.isArray(value)\n      ? IndexedSeq\n      : isPlainObj(value)\n        ? KeyedSeq\n        : null;\n    if (toSeq) {\n      if (~stack.indexOf(value)) {\n        throw new TypeError('Cannot convert circular structure to Immutable');\n      }\n      stack.push(value);\n      keyPath && key !== '' && keyPath.push(key);\n      var converted = converter.call(\n        parentValue,\n        key,\n        toSeq(value).map(function (v, k) { return fromJSWith(stack, converter, v, k, keyPath, value); }\n        ),\n        keyPath && keyPath.slice()\n      );\n      stack.pop();\n      keyPath && keyPath.pop();\n      return converted;\n    }\n    return value;\n  }\n\n  function defaultConverter(k, v) {\n    return isKeyed(v) ? v.toMap() : v.toList();\n  }\n\n  var version = \"4.0.0-rc.11\";\n\n  var Immutable = {\n    version: version,\n\n    Collection: Collection,\n    // Note: Iterable is deprecated\n    Iterable: Collection,\n\n    Seq: Seq,\n    Map: Map,\n    OrderedMap: OrderedMap,\n    List: List,\n    Stack: Stack,\n    Set: Set,\n    OrderedSet: OrderedSet,\n\n    Record: Record,\n    Range: Range,\n    Repeat: Repeat,\n\n    is: is,\n    fromJS: fromJS,\n    hash: hash,\n\n    isImmutable: isImmutable,\n    isCollection: isCollection,\n    isKeyed: isKeyed,\n    isIndexed: isIndexed,\n    isAssociative: isAssociative,\n    isOrdered: isOrdered,\n    isValueObject: isValueObject,\n    isSeq: isSeq,\n    isList: isList,\n    isMap: isMap,\n    isOrderedMap: isOrderedMap,\n    isStack: isStack,\n    isSet: isSet,\n    isOrderedSet: isOrderedSet,\n    isRecord: isRecord,\n\n    get: get,\n    getIn: getIn,\n    has: has,\n    hasIn: hasIn,\n    merge: merge$1,\n    mergeDeep: mergeDeep,\n    mergeWith: mergeWith$1,\n    mergeDeepWith: mergeDeepWith,\n    remove: remove,\n    removeIn: removeIn,\n    set: set,\n    setIn: setIn,\n    update: update,\n    updateIn: updateIn,\n  };\n\n  // Note: Iterable is deprecated\n  var Iterable = Collection;\n\n  exports.default = Immutable;\n  exports.version = version;\n  exports.Collection = Collection;\n  exports.Iterable = Iterable;\n  exports.Seq = Seq;\n  exports.Map = Map;\n  exports.OrderedMap = OrderedMap;\n  exports.List = List;\n  exports.Stack = Stack;\n  exports.Set = Set;\n  exports.OrderedSet = OrderedSet;\n  exports.Record = Record;\n  exports.Range = Range;\n  exports.Repeat = Repeat;\n  exports.is = is;\n  exports.fromJS = fromJS;\n  exports.hash = hash;\n  exports.isImmutable = isImmutable;\n  exports.isCollection = isCollection;\n  exports.isKeyed = isKeyed;\n  exports.isIndexed = isIndexed;\n  exports.isAssociative = isAssociative;\n  exports.isOrdered = isOrdered;\n  exports.isValueObject = isValueObject;\n  exports.get = get;\n  exports.getIn = getIn;\n  exports.has = has;\n  exports.hasIn = hasIn;\n  exports.merge = merge$1;\n  exports.mergeDeep = mergeDeep;\n  exports.mergeWith = mergeWith$1;\n  exports.mergeDeepWith = mergeDeepWith;\n  exports.remove = remove;\n  exports.removeIn = removeIn;\n  exports.set = set;\n  exports.setIn = setIn;\n  exports.update = update;\n  exports.updateIn = updateIn;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]},"metadata":{},"sourceType":"script"}